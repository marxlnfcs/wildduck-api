export type IWildduckApiAddressLimits = components["schemas"]["AddressLimits"];
export type IWildduckApiAutoreplyInfo = components["schemas"]["AutoreplyInfo"];
export type IWildduckApiAutoreply = components["schemas"]["Autoreply"];
export type IWildduckApiLastUse = components["schemas"]["LastUse"];
export type IWildduckApiContentType = components["schemas"]["ContentType"];
export type IWildduckApiDnsTxt = components["schemas"]["DnsTxt"];
export type IWildduckApiQuery = components["schemas"]["Query"];
export type IWildduckApiAction = components["schemas"]["Action"];
export type IWildduckApiSpecialUse = components["schemas"]["SpecialUse"];
export type IWildduckApiEnvelope = components["schemas"]["Envelope"];
export type IWildduckApiRcpt = components["schemas"]["Rcpt"];
export type IWildduckApiAddress = components["schemas"]["Address"];
export type IWildduckApiAddressOptionalName = components["schemas"]["AddressOptionalName"];
export type IWildduckApiList = components["schemas"]["List"];
export type IWildduckApiOutbound = components["schemas"]["Outbound"];
export type IWildduckApiOutboundQueueEntry = components["schemas"]["OutboundQueueEntry"];
export type IWildduckApiAttachments = components["schemas"]["Attachments"];
export type IWildduckApiVerificationResults = components["schemas"]["VerificationResults"];
export type IWildduckApiTls = components["schemas"]["Tls"];
export type IWildduckApiFiles = components["schemas"]["Files"];
export type IWildduckApiHeader = components["schemas"]["Header"];
export type IWildduckApiAttachmentsUpload = components["schemas"]["AttachmentsUpload"];
export type IWildduckApiReferenceWithAttachments = components["schemas"]["ReferenceWithAttachments"];
export type IWildduckApiMessage = components["schemas"]["Message"];
export type IWildduckApiForwarded = components["schemas"]["Forwarded"];
export type IWildduckApiReference = components["schemas"]["Reference"];
export type IWildduckApiEnvelopeUpload = components["schemas"]["EnvelopeUpload"];
export type IWildduckApiMessageWithQueueId = components["schemas"]["MessageWithQueueId"];
export type IWildduckApiKeyInfo = components["schemas"]["KeyInfo"];
export type IWildduckApiUserLimits = components["schemas"]["UserLimits"];
export type IWildduckApiQuota = components["schemas"]["Quota"];
export type IWildduckApiRecipients = components["schemas"]["Recipients"];
export type IWildduckApiFilters = components["schemas"]["Filters"];
export type IWildduckApiForwards = components["schemas"]["Forwards"];
export type IWildduckApiReceived = components["schemas"]["Received"];
export type IWildduckApiImapUpload = components["schemas"]["ImapUpload"];
export type IWildduckApiImapDownload = components["schemas"]["ImapDownload"];
export type IWildduckApiPop3Download = components["schemas"]["Pop3Download"];
export type IWildduckApiImapMaxConnections = components["schemas"]["ImapMaxConnections"];
export type IWildduckApiMailboxes = components["schemas"]["Mailboxes"];
export type IWildduckApiSuccessResponse = components["schemas"]["SuccessResponse"];
export type IWildduckApiUploadMessageRequest = components["schemas"]["UploadMessageRequest"];
export type IWildduckApiForwardStoredMessageRequest = components["schemas"]["ForwardStoredMessageRequest"];
export type IWildduckApiUploadMessageResponse = components["schemas"]["UploadMessageResponse"];
export type IWildduckApiForwardStoredMessageResponse = components["schemas"]["ForwardStoredMessageResponse"];
export type IWildduckApiUploadFileResponse = components["schemas"]["UploadFileResponse"];
export type IWildduckApiGetForwardedAddressResponse = components["schemas"]["GetForwardedAddressResponse"];
export type IWildduckApiGetUserAddressResponse = components["schemas"]["GetUserAddressResponse"];
export type IWildduckApiResolveAddressResponse = components["schemas"]["ResolveAddressResponse"];
export type IWildduckApiGetAddressesResponse = components["schemas"]["GetAddressesResponse"];
export type IWildduckApiGetUserAddressesResponse = components["schemas"]["GetUserAddressesResponse"];
export type IWildduckApiCreateUserAddressResponse = components["schemas"]["CreateUserAddressResponse"];
export type IWildduckApiGetUserAddressesregisterResponse = components["schemas"]["GetUserAddressesregisterResponse"];
export type IWildduckApiCreateForwardedAddressResponse = components["schemas"]["CreateForwardedAddressResponse"];
export type IWildduckApiGetASPResponse = components["schemas"]["GetASPResponse"];
export type IWildduckApiGetASPsResponse = components["schemas"]["GetASPsResponse"];
export type IWildduckApiCreateASPResponse = components["schemas"]["CreateASPResponse"];
export type IWildduckApiGetArchivedMessagesResponse = components["schemas"]["GetArchivedMessagesResponse"];
export type IWildduckApiRestoreMessageResponse = components["schemas"]["RestoreMessageResponse"];
export type IWildduckApiGetAuditResponse = components["schemas"]["GetAuditResponse"];
export type IWildduckApiCreateAuditResponse = components["schemas"]["CreateAuditResponse"];
export type IWildduckApiAuthenticateResponse = components["schemas"]["AuthenticateResponse"];
export type IWildduckApiGetAuthlogResponse = components["schemas"]["GetAuthlogResponse"];
export type IWildduckApiGetAuthlogEventResponse = components["schemas"]["GetAuthlogEventResponse"];
export type IWildduckApiGetAutoreplyResponse = components["schemas"]["GetAutoreplyResponse"];
export type IWildduckApiGetDkimKeyResponse = components["schemas"]["GetDkimKeyResponse"];
export type IWildduckApiGetDkimKeysResponse = components["schemas"]["GetDkimKeysResponse"];
export type IWildduckApiGetTLSCertsResponse = components["schemas"]["GetTLSCertsResponse"];
export type IWildduckApiUpdateDkimKeyResponse = components["schemas"]["UpdateDkimKeyResponse"];
export type IWildduckApiUpdateTLSCertResponse = components["schemas"]["UpdateTLSCertResponse"];
export type IWildduckApiResolveIdResponse = components["schemas"]["ResolveIdResponse"];
export type IWildduckApiRecoverInfoResponse = components["schemas"]["RecoverInfoResponse"];
export type IWildduckApiGetAllowedDomainResponse = components["schemas"]["GetAllowedDomainResponse"];
export type IWildduckApiCreateAllowedDomainResponse = components["schemas"]["CreateAllowedDomainResponse"];
export type IWildduckApiGetBlockedDomainResponse = components["schemas"]["GetBlockedDomainResponse"];
export type IWildduckApiCreateBlockedDomainResponse = components["schemas"]["CreateBlockedDomainResponse"];
export type IWildduckApiGetDomainAliasResponse = components["schemas"]["GetDomainAliasResponse"];
export type IWildduckApiGetDomainAliasesResponse = components["schemas"]["GetDomainAliasesResponse"];
export type IWildduckApiCreateDomainAliasResponse = components["schemas"]["CreateDomainAliasResponse"];
export type IWildduckApiGetFilterResponse = components["schemas"]["GetFilterResponse"];
export type IWildduckApiUpdateFilterResponse = components["schemas"]["UpdateFilterResponse"];
export type IWildduckApiGetAllFiltersResponse = components["schemas"]["GetAllFiltersResponse"];
export type IWildduckApiGetFiltersResponse = components["schemas"]["GetFiltersResponse"];
export type IWildduckApiGetMailboxResponse = components["schemas"]["GetMailboxResponse"];
export type IWildduckApiGetMailboxesResponse = components["schemas"]["GetMailboxesResponse"];
export type IWildduckApiCreateMailboxResponse = components["schemas"]["CreateMailboxResponse"];
export type IWildduckApiGetMessageResponse = components["schemas"]["GetMessageResponse"];
export type IWildduckApiDeleteMessagesInMailboxResponse = components["schemas"]["DeleteMessagesInMailboxResponse"];
export type IWildduckApiGetMessagesResponse = components["schemas"]["GetMessagesResponse"];
export type IWildduckApiUpdateMessageResponse = components["schemas"]["UpdateMessageResponse"];
export type IWildduckApiSearchMessagesResponse = components["schemas"]["SearchMessagesResponse"];
export type IWildduckApiSubmitStoredMessageResponse = components["schemas"]["SubmitStoredMessageResponse"];
export type IWildduckApiGetFilesResponse = components["schemas"]["GetFilesResponse"];
export type IWildduckApiSubmitMessageResponse = components["schemas"]["SubmitMessageResponse"];
export type IWildduckApiSetupTotp2FAResponse = components["schemas"]["SetupTotp2FAResponse"];
export type IWildduckApiGetUserResponse = components["schemas"]["GetUserResponse"];
export type IWildduckApiGetUsersResponse = components["schemas"]["GetUsersResponse"];
export type IWildduckApiCreateUserResponse = components["schemas"]["CreateUserResponse"];
export type IWildduckApiRecalculateQuotaResponse = components["schemas"]["RecalculateQuotaResponse"];
export type IWildduckApiResetUserPasswordResponse = components["schemas"]["ResetUserPasswordResponse"];
export type IWildduckApiGetWebhooksResponse = components["schemas"]["GetWebhooksResponse"];
export type IWildduckApiCreateWebhookResponse = components["schemas"]["CreateWebhookResponse"];
export type IWildduckApiGetSettingResponse = components["schemas"]["GetSettingResponse"];
export type IWildduckApiGetSettingsResponse = components["schemas"]["GetSettingsResponse"];
export type IWildduckApiCreateSettingResponse = components["schemas"]["CreateSettingResponse"];
export type IWildduckApiUpdateForwardedAddressRequest = components["schemas"]["UpdateForwardedAddressRequest"];
export type IWildduckApiUpdateUserAddressRequest = components["schemas"]["UpdateUserAddressRequest"];
export type IWildduckApiCreateUserAddressRequest = components["schemas"]["CreateUserAddressRequest"];
export type IWildduckApiCreateForwardedAddressRequest = components["schemas"]["CreateForwardedAddressRequest"];
export type IWildduckApiRenameDomainRequest = components["schemas"]["RenameDomainRequest"];
export type IWildduckApiCreateASPRequest = components["schemas"]["CreateASPRequest"];
export type IWildduckApiRestoreMessageRequest = components["schemas"]["RestoreMessageRequest"];
export type IWildduckApiRestoreMessagesRequest = components["schemas"]["RestoreMessagesRequest"];
export type IWildduckApiCreateAuditRequest = components["schemas"]["CreateAuditRequest"];
export type IWildduckApiAuthenticateRequest = components["schemas"]["AuthenticateRequest"];
export type IWildduckApiUpdateAutoreplyRequest = components["schemas"]["UpdateAutoreplyRequest"];
export type IWildduckApiUpdateDkimKeyRequest = components["schemas"]["UpdateDkimKeyRequest"];
export type IWildduckApiUpdateTLSCertRequest = components["schemas"]["UpdateTLSCertRequest"];
export type IWildduckApiCreateAllowedDomainRequest = components["schemas"]["CreateAllowedDomainRequest"];
export type IWildduckApiCreateBlockedDomainRequest = components["schemas"]["CreateBlockedDomainRequest"];
export type IWildduckApiCreateDomainAliasRequest = components["schemas"]["CreateDomainAliasRequest"];
export type IWildduckApiUpdateFilterRequest = components["schemas"]["UpdateFilterRequest"];
export type IWildduckApiCreateFilterRequest = components["schemas"]["CreateFilterRequest"];
export type IWildduckApiUpdateMailboxRequest = components["schemas"]["UpdateMailboxRequest"];
export type IWildduckApiCreateMailboxRequest = components["schemas"]["CreateMailboxRequest"];
export type IWildduckApiUpdateMessageRequest = components["schemas"]["UpdateMessageRequest"];
export type IWildduckApiSubmitStoredMessageRequest = components["schemas"]["SubmitStoredMessageRequest"];
export type IWildduckApiSubmitMessageRequest = components["schemas"]["SubmitMessageRequest"];
export type IWildduckApiCheckTotp2FARequest = components["schemas"]["CheckTotp2FARequest"];
export type IWildduckApiEnableCustom2FARequest = components["schemas"]["EnableCustom2FARequest"];
export type IWildduckApiEnableTotp2FARequest = components["schemas"]["EnableTotp2FARequest"];
export type IWildduckApiSetupTotp2FARequest = components["schemas"]["SetupTotp2FARequest"];
export type IWildduckApiUpdateUserRequest = components["schemas"]["UpdateUserRequest"];
export type IWildduckApiCreateUserRequest = components["schemas"]["CreateUserRequest"];
export type IWildduckApiLogoutUserRequest = components["schemas"]["LogoutUserRequest"];
export type IWildduckApiUserRestoreRequest = components["schemas"]["UserRestoreRequest"];
export type IWildduckApiResetUserPasswordRequest = components["schemas"]["ResetUserPasswordRequest"];
export type IWildduckApiCreateWebhookRequest = components["schemas"]["CreateWebhookRequest"];
export type IWildduckApiCreateSettingRequest = components["schemas"]["CreateSettingRequest"];
export type IWildduckApiGetAddressesResult = components["schemas"]["GetAddressesResult"];
export type IWildduckApiGetUserAddressesResult = components["schemas"]["GetUserAddressesResult"];
export type IWildduckApiGetUserAddressesregisterResult = components["schemas"]["GetUserAddressesregisterResult"];
export type IWildduckApiGetASPsResult = components["schemas"]["GetASPsResult"];
export type IWildduckApiGetArchivedMessagesResult = components["schemas"]["GetArchivedMessagesResult"];
export type IWildduckApiGetAuthlogResult = components["schemas"]["GetAuthlogResult"];
export type IWildduckApiGetDkimKeysResult = components["schemas"]["GetDkimKeysResult"];
export type IWildduckApiGetTLSCertResult = components["schemas"]["GetTLSCertResult"];
export type IWildduckApiGetAllowedDomainResult = components["schemas"]["GetAllowedDomainResult"];
export type IWildduckApiGetBlockedDomainResult = components["schemas"]["GetBlockedDomainResult"];
export type IWildduckApiGetDomainAliasesResult = components["schemas"]["GetDomainAliasesResult"];
export type IWildduckApiGetAllFiltersResult = components["schemas"]["GetAllFiltersResult"];
export type IWildduckApiGetFiltersResult = components["schemas"]["GetFiltersResult"];
export type IWildduckApiGetMailboxesResult = components["schemas"]["GetMailboxesResult"];
export type IWildduckApiGetMessagesResult = components["schemas"]["GetMessagesResult"];
export type IWildduckApiGetFilesResult = components["schemas"]["GetFilesResult"];
export type IWildduckApiGetUsersResult = components["schemas"]["GetUsersResult"];
export type IWildduckApiGetWebhooksResult = components["schemas"]["GetWebhooksResult"];
export type IWildduckApiAspScopes = components["schemas"]["AspScopes"];
export type IWildduckApiDisabledScopes = components["schemas"]["DisabledScopes"];
export type IWildduckApiOrder = components["schemas"]["Order"];
export type IWildduckApiGetSettingsResult = components["schemas"]["GetSettingsResult"];

interface paths {
  "/addresses/forwarded/{address}": {
    get: operations["getForwardedAddress"];
    put: operations["updateForwardedAddress"];
    delete: operations["deleteForwardedAddress"];
    parameters: {
      path: {
        /** ID of the Address */
        address: string;
      };
    };
  };
  "/users/{user}/addresses/{address}": {
    get: operations["getUserAddress"];
    put: operations["updateUserAddress"];
    delete: operations["deleteUserAddress"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Address */
        address: string;
      };
    };
  };
  "/addresses/resolve/{address}": {
    get: operations["resolveAddress"];
    parameters: {
      path: {
        /** ID of the Address or e-mail address string */
        address: string;
      };
    };
  };
  "/addresses": {
    get: operations["getAddresses"];
  };
  "/users/{user}/addresses": {
    get: operations["getUserAddresses"];
    /** Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both "firstlast@example.com" and "first.last@example.com" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument) */
    post: operations["createUserAddress"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/addressregister": {
    /** Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage. */
    get: operations["getUserAddressregister"];
  };
  "/addresses/forwarded": {
    /** Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both "firstlast@example.com" and "first.last@example.com" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument) */
    post: operations["createForwardedAddress"];
  };
  "/addresses/renameDomain": {
    /** Renames domain names for addresses, DKIM keys and Domain Aliases */
    put: operations["renameDomain"];
  };
  "/users/{user}/asps/{asp}": {
    get: operations["getASP"];
    delete: operations["deleteASP"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Application Password */
        asp: string;
      };
    };
  };
  "/users/{user}/asps": {
    get: operations["getASPs"];
    post: operations["createASP"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/archived/messages": {
    /** Archive contains all recently deleted messages besides Drafts etc. */
    get: operations["getArchivedMessages"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/archived/messages/{message}/restore": {
    /** Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX. */
    post: operations["restoreMessage"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** Message ID */
        message: number;
      };
    };
  };
  "/users/{user}/archived/restore": {
    /** Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX. */
    post: operations["restoreMessages"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/audit/{audit}": {
    /** This method returns information about stored audit */
    get: operations["getAudit"];
    parameters: {
      path: {
        /** ID of the Audit */
        audit: string;
      };
    };
  };
  "/audit/{audit}/export.mbox": {
    /** This method returns a mailbox file that contains all audited emails */
    get: operations["getAuditEmails"];
    parameters: {
      path: {
        /** ID of the Audit */
        audit: string;
      };
    };
  };
  "/audit": {
    /** Initiates a message audit */
    post: operations["createAudit"];
  };
  "/authenticate": {
    post: operations["authenticate"];
    /** This method invalidates currently used authentication token. If token is not provided then nothing happens */
    delete: operations["invalidateAccessToken"];
  };
  "/preauth": {
    /** Check if an username exists and can be used for authentication */
    post: operations["preauth"];
  };
  "/users/{user}/authlog": {
    get: operations["getAuthlog"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/authlog/{event}": {
    get: operations["getAuthlogEvent"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Event */
        event: string;
      };
    };
  };
  "/users/{user}/autoreply": {
    get: operations["getAutoreply"];
    put: operations["updateAutoreply"];
    delete: operations["deleteAutoreply"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/dkim/{dkim}": {
    get: operations["getDkimKey"];
    delete: operations["deleteDkimKey"];
    parameters: {
      path: {
        /** ID of the DKIM */
        dkim: string;
      };
    };
  };
  "/dkim": {
    get: operations["getDkimKeys"];
    /** Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name. */
    post: operations["updateDkimKey"];
  };
  "/dkim/resolve/{domain}": {
    get: operations["resolveDkim"];
    parameters: {
      path: {
        /** DKIM domain */
        domain: string;
      };
    };
  };
  "/certs/{cert}": {
    get: operations["getTLSCerticate"];
    delete: operations["deleteTlsCert"];
    parameters: {
      path: {
        /** ID of the TLS certificate */
        cert: string;
      };
    };
  };
  "/certs": {
    get: operations["getTLSCerticates"];
    /**
     * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for "mydomain.com" that includes "\*.mydomain.com" in SAN and the same certificate would be used for requests that do not have it's own server name registered but match the SAN value.
     * > NB! you must ensure yourself that the `servername` value is actually listed in certificate's common name or SAN as WildDuck is going to use this certificate regardless.
     */
    post: operations["updateTLSCertificate"];
  };
  "/certs/resolve/{servername}": {
    get: operations["resolveTLSCertificate"];
    parameters: {
      path: {
        /** Server name */
        servername: string;
      };
    };
  };
  "/domainaccess/{domain}": {
    delete: operations["deleteDomainListing"];
    parameters: {
      path: {
        /** Listed domains unique ID */
        domain: string;
      };
    };
  };
  "/domainaccess/{tag}/allow": {
    get: operations["getAllowedDomain"];
    /** If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users. */
    post: operations["createAllowedDomain"];
    parameters: {
      path: {
        /** Tag to look for */
        tag: string;
      };
    };
  };
  "/domainaccess/{tag}/block": {
    get: operations["getBlockedDomain"];
    /** If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users. */
    post: operations["createBlockedDomain"];
    parameters: {
      path: {
        /** Tag to look for */
        tag: string;
      };
    };
  };
  "/domainaliases/{alias}": {
    get: operations["getDomainAlias"];
    delete: operations["deleteDomainAlias"];
    parameters: {
      path: {
        /** ID of the Alias */
        alias: string;
      };
    };
  };
  "/domainaliases": {
    get: operations["getDomainAliases"];
    /** Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias */
    post: operations["createDomainAlias"];
  };
  "/domainaliases/resolve/{alias}": {
    get: operations["resolveDomainAlias"];
    parameters: {
      path: {
        /** Alias domain */
        alias: string;
      };
    };
  };
  "/data/export": {
    /** Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special "export"-role access token is required for exporting and importing. */
    post: operations["createExport"];
  };
  "/data/import": {
    /** Import data from an export dump. If a database entry already exists, it is not modified. A special "export"-role access token is required for exporting and importing. */
    post: operations["createImport"];
  };
  "/users/{user}/filters/{filter}": {
    get: operations["getFilter"];
    /** This method updates Filter data. To unset a value, use empty strings */
    put: operations["updateFilter"];
    delete: operations["deleteFilter"];
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Filters unique ID */
        filter: string;
      };
    };
  };
  "/filters": {
    get: operations["getAllFilters"];
  };
  "/users/{user}/filters": {
    get: operations["getFilters"];
    post: operations["createFilter"];
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}": {
    get: operations["getMailbox"];
    put: operations["updateMailbox"];
    delete: operations["deleteMailbox"];
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Mailbox unique ID. Special use folders and INBOX can not be deleted */
        mailbox: string;
      };
    };
  };
  "/users/{user}/mailboxes": {
    get: operations["getMailboxes"];
    post: operations["createMailbox"];
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}/messages/{message}": {
    get: operations["getMessage"];
    delete: operations["deleteMessage"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}/messages": {
    get: operations["getMessages"];
    /** This method updates message flags and also allows to move messages to a different mailbox */
    put: operations["updateMessage"];
    /** This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property. */
    post: operations["uploadMessage"];
    delete: operations["deleteMessagesInMailbox"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}/messages/{message}/forward": {
    /** This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message. */
    post: operations["forwardStoredMessage"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}/messages/{message}/attachments/{attachment}": {
    /** This method returns attachment file contents in binary form */
    get: operations["getMessageAttachment"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** ID of the Message */
        message: number;
        /** ID of the Attachment */
        attachment: string;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}/messages/{message}/message.eml": {
    /** This method returns the full RFC822 formatted source of the stored message */
    get: operations["getMessageSource"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** ID of the Message */
        message: number;
      };
    };
  };
  "/users/{user}/outbound/{queueId}": {
    /** You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email. */
    delete: operations["deleteOutboundMessage"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** Outbound queue ID of the message */
        queueId: string;
      };
    };
  };
  "/users/{user}/search": {
    /** This method allows searching for matching messages. */
    get: operations["searchMessages"];
    /** This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background. */
    post: operations["searchApplyMessages"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/mailboxes/{mailbox}/messages/{message}/submit": {
    /** This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder. */
    post: operations["submitStoredMessage"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
    };
  };
  "/users/{user}/storage/{file}": {
    /** This method returns stored file contents in binary form */
    get: operations["getFile"];
    delete: operations["deleteFile"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the File */
        file: string;
      };
    };
  };
  "/users/{user}/storage": {
    get: operations["getFiles"];
    /** This method allows to upload an attachment to be linked from a draft */
    post: operations["uploadFile"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/submit": {
    /** Use this method to send emails from a user account */
    post: operations["submitMessage"];
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
  };
  "/users/{user}/2fa/totp/check": {
    /** This method checks if a TOTP token provided by a User is valid for authentication */
    post: operations["checkTotp2FA"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/2fa": {
    /** This method disables all 2FA mechanisms a user might have set up */
    delete: operations["disable2FA"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/2fa/custom": {
    /** This method disables account password for IMAP/POP3/SMTP */
    put: operations["enableCustom2FA"];
    /** This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again */
    delete: operations["disableCustom2FA"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/2fa/totp": {
    /** This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up */
    delete: operations["disableTotp2FA"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/2fa/totp/enable": {
    /** This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup */
    post: operations["enableTotp2FA"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{user}/2fa/totp/setup": {
    /** This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint */
    post: operations["setupTotp2FA"];
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
  };
  "/users/{id}": {
    get: operations["getUser"];
    put: operations["updateUser"];
    /** This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages. */
    delete: operations["deleteUser"];
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
  };
  "/users/{id}/updates": {
    /** This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings */
    get: operations["getUpdates"];
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
  };
  "/users/resolve/{username}": {
    get: operations["resolveUser"];
    parameters: {
      path: {
        /** Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only ("user.name" is the same as "username") */
        username: string;
      };
    };
  };
  "/users/{id}/restore": {
    get: operations["restoreUserInfo"];
    /** Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled */
    post: operations["restoreUser"];
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
  };
  "/users": {
    get: operations["getUsers"];
    post: operations["createUser"];
  };
  "/users/{user}/quota/reset": {
    /** This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact. */
    post: operations["recalculateQuota"];
    parameters: {
      path: {
        /** Users unique ID. */
        user: string;
      };
    };
  };
  "/quota/reset": {
    /** This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact. */
    post: operations["recalculateQuotaAllUsers"];
  };
  "/users/{id}/logout": {
    /** This method logs out all user sessions in IMAP */
    put: operations["logoutUser"];
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
  };
  "/users/{id}/password/reset": {
    /** This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings */
    post: operations["resetUserPassword"];
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
  };
  "/webhooks/{webhook}": {
    delete: operations["deleteWebhook"];
    parameters: {
      path: {
        /** ID of the Webhook */
        webhook: string;
      };
    };
  };
  "/webhooks": {
    get: operations["getWebhooks"];
    /** Create new webhook */
    post: operations["createWebhook"];
  };
  "/settings/{setting}": {
    get: operations["getSetting"];
    /** Create a new or update an existing setting */
    post: operations["createSetting"];
    delete: operations["deleteSetting"];
    parameters: {
      path: {
        /** Key of the Setting */
        setting: string;
      };
    };
  };
  "/settings": {
    get: operations["getSettings"];
  };
}

interface components {
  schemas: {
    /** @description Account limits and usage */
    AddressLimits: {
      forwards: components["schemas"]["Forwards"];
    };
    /** @description Autoreply information */
    AutoreplyInfo: {
      /** @description If true, then autoreply is enabled for this address */
      status: boolean;
      /** @description Name that is used for the From: header in autoreply message */
      name: string;
      /** @description Autoreply subject line */
      subject: string;
      /** @description Autoreply plaintext content */
      text: string;
      /** @description Autoreply HTML content */
      html: string;
    };
    /** @description Autoreply information */
    Autoreply: {
      /** @description If true, then autoreply is enabled for this address */
      status?: boolean;
      /**
       * Format: date-time
       * @description Either a date string or boolean false to disable start time checks
       */
      start?: string;
      /**
       * Format: date-time
       * @description Either a date string or boolean false to disable end time checks
       */
      end?: string;
      /** @description Name that is used for the From: header in autoreply message */
      name?: string;
      /** @description Autoreply subject line */
      subject?: string;
      /** @description Autoreply plaintext content */
      text?: string;
      /** @description Autoreply HTML content */
      html?: string;
    };
    /** @description Information about last use */
    LastUse: {
      /**
       * Format: date-time
       * @description Datestring of last use or false if password has not been used
       */
      time: string;
      /** @description Event ID of the security log for the last authentication */
      event: string;
    };
    /** @description Parsed Content-Type header. Usually needed to identify encrypted messages and such */
    ContentType: {
      /** @description MIME type of the message, eg. "multipart/mixed" */
      value: string;
      /** @description An object with Content-Type params as key-value pairs */
      params: { [key: string]: unknown };
    };
    /** @description Value for DNS TXT entry */
    DnsTxt: {
      /** @description Is the domain name of TXT */
      name: string;
      /** @description Is the value of TXT */
      value: string;
    };
    /** @description Rules that a message must match */
    Query: {
      /** @description Partial match for the From: header (case insensitive) */
      from?: string;
      /** @description Partial match for the To:/Cc: headers (case insensitive) */
      to?: string;
      /** @description Partial match for the Subject: header (case insensitive) */
      subject?: string;
      /** @description Partial match for the List-ID: header (case insensitive) */
      listId?: string;
      /** @description Fulltext search against message text */
      text?: string;
      /** @description Does a message have to have an attachment or not */
      ha?: boolean;
      /** @description Message size in bytes. If the value is a positive number then message needs to be larger, if negative then message needs to be smaller than abs(size) value */
      size?: number;
    };
    /** @description Action to take with a matching message */
    Action: {
      /** @description If true then mark matching messages as Seen */
      seen?: boolean;
      /** @description If true then mark matching messages as Flagged */
      flag?: boolean;
      /** @description If true then do not store matching messages */
      delete?: boolean;
      /** @description If true then store matching messags to Junk Mail folder */
      spam?: boolean;
      /** @description Mailbox ID to store matching messages to */
      mailbox?: string;
      /** @description An array of forwarding targets. The value could either be an email address or a relay url to next MX server ("smtp://mx2.zone.eu:25") or an URL where mail contents are POSTed to */
      targets?: string[];
    };
    /**
     * @description Either special use identifier or null. One of \Drafts, \Junk, \Sent or \Trash
     * @enum {string}
     */
    SpecialUse: "Drafts" | "Junk" | "Sent" | "Trash";
    /** @description SMTP envelope (if available) */
    Envelope: {
      /** @description Address from MAIL FROM */
      from: string;
      rcpt: components["schemas"]["Rcpt"];
    };
    /** @description Array of addresses from RCPT TO (should have just one normally) */
    Rcpt: {
      /** @description RCPT TO address as provided by SMTP client */
      value: string;
      /** @description Normalized RCPT address */
      formatted: string;
    };
    Address: {
      /** @description Name of the sender/recipient */
      name: string;
      /** @description Address of the sender/recipient */
      address: string;
    };
    AddressOptionalName: {
      /** @description Name of the sender */
      name?: string;
      /** @description Address of the sender */
      address: string;
    };
    /** @description If set then this message is from a mailing list */
    List: {
      /** @description Value from List-ID header */
      id: string;
      /** @description Value from List-Unsubscribe header */
      unsubscribe: string;
    };
    Outbound: {
      /** @description Queue ID */
      queueId: string;
      /** @description Queued recipients */
      entries: components["schemas"]["OutboundQueueEntry"][];
    };
    OutboundQueueEntry: {
      /** @description Queue target ID */
      seq: string;
      /** @description Target recipient */
      recipient: string;
      /** @description Zone ID in ZoneMTA */
      sendingZone?: string;
      /** @description ISO Date of the expected delivery time */
      queued?: string;
    };
    /** @description List of attachments for this message */
    Attachments: {
      /** @description Attachment ID */
      id: string;
      /** @description SHA-256 hash of the contents of the attachment */
      hash?: string;
      /** @description Filename of the attachment */
      filename: string;
      /** @description MIME type */
      contentType: string;
      /** @description Attachment disposition */
      disposition: string;
      /** @description Which transfer encoding was used (actual content when fetching attachments is not encoded) */
      transferEncoding: string;
      /** @description Was this attachment found from a multipart/related node. This usually means that this is an embedded image */
      related: boolean;
      /** @description Approximate size of the attachment in kilobytes */
      sizeKb: number;
    };
    /** @description Security verification info if message was received from MX. If this property is missing then do not automatically assume invalid TLS, SPF or DKIM. */
    VerificationResults: {
      tls: components["schemas"]["Tls"];
      /** @description Domain name (either MFROM or HELO) of verified SPF or false if no SPF match was found */
      spf: { [key: string]: unknown };
      /** @description Domain name of verified DKIM signature or false if no valid signature was found */
      dkim: { [key: string]: unknown };
    };
    /** @description TLS information. Value is false if TLS was not used */
    Tls: {
      /** @description Cipher name, eg "ECDHE-RSA-AES128-GCM-SHA256" */
      name: { [key: string]: unknown };
      /** @description TLS version, eg "TLSv1/SSLv3" */
      version: { [key: string]: unknown };
    };
    /** @description List of files added to this message as attachments. Applies to Drafts, normal messages do not have this property. Needed to prevent uploading the same attachment every time a draft is updated */
    Files: {
      /** @description File ID */
      id: string;
      /** @description Filename of the attached file */
      filename: string;
      /** @description MIME type */
      contentType: string;
      /** @description MIME type */
      size: number;
    };
    Header: {
      /** @description Header key ('X-Mailer') */
      key: string;
      /** @description Header value ('My Awesome Mailing Service') */
      value: string;
    };
    AttachmentsUpload: {
      /** @description Base64 encoded attachment content */
      content: string;
      /** @description Attachment filename */
      filename?: string;
      /** @description MIME type for the attachment file */
      contentType?: string;
      /** @description Content-ID value if you want to reference to this attachment from HTML formatted message */
      cid?: string;
    };
    /** @description Optional referenced email. If uploaded message is a reply draft and relevant fields are not provided then these are resolved from the message to be replied to */
    ReferenceWithAttachments: {
      /** @description Mailbox ID */
      mailbox: string;
      /** @description Message ID in Mailbox */
      id: number;
      /** @description Either reply, replyAll or forward */
      action: string;
      /** @description If true, then includes all attachments from the original message. If it is an array of attachment ID's includes attachments from the list */
      attachments: string[];
    };
    /** @description Message information */
    Message: {
      /** @description Message ID in mailbox */
      id: number;
      /** @description Mailbox ID the message was stored into */
      mailbox: string;
      /** @description Size of the RFC822 formatted email */
      size?: number;
    };
    Forwarded: {
      /** @description Sequence ID */
      seq: string;
      /** @description Target type */
      type: string;
      /** @description Target address */
      value: string;
    };
    /** @description Optional referenced email. If submitted message is a reply and relevant fields are not provided then these are resolved from the message to be replied to */
    Reference: {
      /** @description Mailbox ID */
      mailbox: string;
      /** @description Message ID in Mailbox */
      id: number;
      /** @description Either reply, replyAll or forward */
      action: string;
    };
    /** @description SMTP envelope. If not provided then resolved either from message headers or from referenced message */
    EnvelopeUpload: {
      from?: components["schemas"]["AddressOptionalName"];
      /** @description Recipients information */
      to?: components["schemas"]["AddressOptionalName"][];
    };
    /** @description Information about submitted Message */
    MessageWithQueueId: {
      /** @description Mailbox ID the message was stored to */
      mailbox: string;
      /** @description Message ID in Mailbox */
      id: number;
      /** @description Queue ID in MTA */
      queueId: string;
    };
    /** @description Information about public key or false if key is not available */
    KeyInfo: {
      /** @description Name listed in public key */
      name: string;
      /** @description E-mail address listed in public key */
      address: string;
      /** @description Fingerprint of the public key */
      fingerprint: string;
    };
    /** @description Account limits and usage */
    UserLimits: {
      quota: components["schemas"]["Quota"];
      recipients: components["schemas"]["Recipients"];
      filters?: components["schemas"]["Filters"];
      forwards: components["schemas"]["Forwards"];
      received: components["schemas"]["Received"];
      imapUpload: components["schemas"]["ImapUpload"];
      imapDownload: components["schemas"]["ImapDownload"];
      pop3Download: components["schemas"]["Pop3Download"];
      imapMaxConnections?: components["schemas"]["ImapMaxConnections"];
    };
    /** @description Quota usage limits */
    Quota: {
      /** @description Allowed quota of the user in bytes */
      allowed: number;
      /** @description Space used in bytes */
      used: number;
    };
    /** @description Sending quota */
    Recipients: {
      /** @description How many messages per 24 hours can be sent */
      allowed: number;
      /** @description How many messages are sent during current 24 hour period */
      used: number;
      /** @description Time until the end of current 24 hour period */
      ttl: number;
    };
    /** @description Sending quota */
    Filters: {
      /** @description How many filters are allowed */
      allowed: number;
      /** @description How many filters have been created */
      used: number;
    };
    /** @description Forwarding quota */
    Forwards: {
      /** @description How many messages per 24 hours can be forwarded */
      allowed: number;
      /** @description How many messages are forwarded during current 24 hour period */
      used: number;
      /** @description Time until the end of current 24 hour period */
      ttl: number;
    };
    /** @description Receiving quota */
    Received: {
      /** @description How many messages per 1 hour can be received */
      allowed: number;
      /** @description How many messages are received during current 1 hour period */
      used: number;
      /** @description Time until the end of current 1 hour period */
      ttl: number;
    };
    /** @description IMAP upload quota */
    ImapUpload: {
      /** @description How many bytes per 24 hours can be uploaded via IMAP. Only message contents are counted, not protocol overhead. */
      allowed: number;
      /** @description How many bytes are uploaded during current 24 hour period */
      used: number;
      /** @description Time until the end of current 24 hour period */
      ttl: number;
    };
    /** @description IMAP download quota */
    ImapDownload: {
      /** @description How many bytes per 24 hours can be downloaded via IMAP. Only message contents are counted, not protocol overhead. */
      allowed: number;
      /** @description How many bytes are downloaded during current 24 hour period */
      used: number;
      /** @description Time until the end of current 24 hour period */
      ttl: number;
    };
    /** @description POP3 download quota */
    Pop3Download: {
      /** @description How many bytes per 24 hours can be downloaded via POP3. Only message contents are counted, not protocol overhead. */
      allowed: number;
      /** @description How many bytes are downloaded during current 24 hour period */
      used: number;
      /** @description Time until the end of current 24 hour period */
      ttl: number;
    };
    ImapMaxConnections: {
      /** @description How many parallel IMAP connections are permitted */
      allowed: number;
      /** @description How many parallel IMAP connections are currenlty in use */
      used: number;
    };
    /** @description Optional names for special mailboxes */
    Mailboxes: {
      /** @description Path of Sent Mail folder */
      sent?: string;
      /** @description Path of spam folder */
      junk?: string;
      /** @description Path of drafts folder */
      drafts?: string;
      /** @description Path of trash folder */
      trash?: string;
    };
    SuccessResponse: {
      /** @description Indicates successful response */
      success: boolean;
    };
    UploadMessageRequest: {
      /** @description Is the message unseen or not */
      unseen?: boolean;
      /** @description Is the message a draft or not */
      draft?: boolean;
      /** @description Is the message flagged or not */
      flagged?: boolean;
      /** @description base64 encoded message source. Alternatively, you can provide this value as POST body by using message/rfc822 MIME type. If raw message is provided then it overrides any other mail configuration */
      raw?: string;
      from?: components["schemas"]["Address"];
      /** @description Addresses for the To: header */
      to?: components["schemas"]["AddressOptionalName"][];
      /** @description Addresses for the Cc: header */
      cc?: components["schemas"]["AddressOptionalName"][];
      /** @description Addresses for the Bcc: header */
      bcc?: components["schemas"]["AddressOptionalName"][];
      /** @description Message subject. If not then resolved from Reference message */
      subject?: string;
      /** @description Plaintext message */
      text?: string;
      /** @description HTML formatted message */
      html?: string;
      /** @description Custom headers for the message. If reference message is set then In-Reply-To and References headers are set  automaticall y */
      headers?: components["schemas"]["Header"][];
      /** @description Attachments as storage file IDs. NB! When retrieving message info then an array of objects is returned. When uploading a message then an array of IDs is used. */
      files?: string[];
      /** @description Attachments for the message */
      attachments?: components["schemas"]["AttachmentsUpload"][];
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      reference?: components["schemas"]["ReferenceWithAttachments"];
      /** @description Marks BIMI verification as passed for a domain. NB! BIMI record and logo files for the domain must be valid. */
      bimi?: {
        /** @description Domain name for the BIMI record. It does not have to be the same as the From address. */
        domain: string;
        /** @description Optional BIMI selector */
        selector?: string;
      };
      /** @description If set, then deletes a previous message when storing the new one. Useful when uploading a new Draft message. */
      replacePrevious?: {
        /** @description Mailbox ID. Defaults to the mailbox of the uploaded message. */
        mailbox?: string;
        /** @description Message ID in Mailbox */
        id: number;
      };
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    ForwardStoredMessageRequest: {
      /** @description Number of original forwarding target */
      target?: number;
      /** @description An array of additional forward targets */
      addresses?: string[];
    };
    UploadMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      message: components["schemas"]["Message"];
      /** @description Set if replacing a previous message was requested */
      previousDeleted?: boolean;
    };
    ForwardStoredMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Message ID in outbound queue */
      queueId: string;
      /** @description Information about forwarding targets */
      forwarded: components["schemas"]["Forwarded"][];
    };
    UploadFileResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description File ID */
      id: { [key: string]: unknown };
    };
    GetForwardedAddressResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Address */
      id: string;
      /** @description E-mail address string */
      address: string;
      /** @description Identity name */
      name: string;
      /** @description List of forwarding targets */
      targets: string[];
      limits: components["schemas"]["AddressLimits"];
      autoreply: components["schemas"]["AutoreplyInfo"];
      /**
       * Format: date-time
       * @description Datestring of the time the address was created
       */
      created: string;
      /** @description List of tags associated with the Address */
      tags: string[];
      /** @description If true then the forwarded address is disabled */
      forwardedDisabled: boolean;
    };
    GetUserAddressResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Address */
      id: string;
      /** @description Identity name */
      name: string;
      /** @description E-mail address string */
      address: string;
      /** @description List of tags associated with the Address */
      tags: string[];
      /** @description Metadata object (if available) */
      metaData?: { [key: string]: unknown };
      /** @description Internal metadata object (if available), not included for user-role requests */
      internalData?: { [key: string]: unknown };
      /** @description Indicates if this is the default address for the User */
      main: boolean;
      /**
       * Format: date-time
       * @description Datestring of the time the address was created
       */
      created: string;
    };
    ResolveAddressResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Address */
      id: string;
      /** @description E-mail address string */
      address: string;
      /** @description Identity name */
      name: string;
      /** @description ID of the user if the address belongs to a User */
      user: string;
      /** @description List of forwarding targets if this is a Forwarded address */
      targets: string[];
      limits: components["schemas"]["AddressLimits"];
      autoreply: components["schemas"]["AutoreplyInfo"];
      /** @description List of tags associated with the Address */
      tags: string[];
      /**
       * Format: date-time
       * @description Datestring of the time the address was created
       */
      created: string;
    };
    GetAddressesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Address listing */
      results: components["schemas"]["GetAddressesResult"][];
    };
    GetUserAddressesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Address listing */
      results: components["schemas"]["GetUserAddressesResult"][];
    };
    CreateUserAddressResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Address */
      id: string;
    };
    GetUserAddressesregisterResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Address listing */
      results: components["schemas"]["GetUserAddressesregisterResult"][];
    };
    CreateForwardedAddressResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Address */
      id: string;
    };
    GetASPResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Application Password */
      id: string;
      /** @description Description */
      description: string;
      /** @description Allowed scopes for the Application Password */
      scopes: components["schemas"]["AspScopes"][];
      lastUse: components["schemas"]["LastUse"];
      /**
       * Format: date-time
       * @description Datestring
       */
      created: string;
    };
    GetASPsResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Event listing */
      results: components["schemas"]["GetASPsResult"][];
    };
    CreateASPResponse: {
      /**
       * @description Indicates successful response
       * @example true
       */
      success: boolean;
      /**
       * @description ID of the Application Password
       * @example 60b91b5cc419d97445f8e57d
       */
      id: string;
      /**
       * @description Application Specific Password. Generated password is whitespace agnostic, so it could be displayed to the client as "abcd efgh ijkl mnop" instead of "abcdefghijklmnop"
       * @example aaaaaaaaaaaaaaaa
       */
      password: string;
      /** @description Base64 encoded mobileconfig file. Generated profile file should be sent to the client with Content-Type value of application/x-apple-aspen-config. */
      mobileconfig: string;
    };
    GetArchivedMessagesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Message listing */
      results: components["schemas"]["GetArchivedMessagesResult"][];
    };
    RestoreMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Maibox ID the message was moved to */
      mailbox: string;
      /** @description New ID for the Message */
      id: number;
    };
    GetAuditResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Users unique ID. */
      user: string;
      /**
       * Format: date-time
       * @description Start time as ISO date
       */
      start?: string;
      /**
       * Format: date-time
       * @description End time as ISO date
       */
      end?: string;
      /**
       * Format: date-time
       * @description Expiration date. Audit data is deleted after this date
       */
      expires: string;
    };
    CreateAuditResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID for the created Audit */
      id: string;
    };
    AuthenticateResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of authenticated User */
      id: string;
      /** @description Username of authenticated User */
      username: string;
      /** @description The scope this authentication is valid for */
      scope: string;
      /** @description List of enabled 2FA mechanisms */
      require2fa: string[];
      /** @description Indicates if account hassword has been reset and should be replaced */
      requirePasswordChange: boolean;
      /** @description If access token was requested then this is the value to use as access token when making API requests on behalf of logged in user. */
      token?: string;
    };
    GetAuthlogResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Event listing */
      results: components["schemas"]["GetAuthlogResult"][];
    };
    GetAuthlogEventResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Event */
      id: string;
      /** @description Action identifier */
      action: string;
      /** @description Did the action succeed */
      result: string;
      /** @description Session identifier */
      sess?: string;
      /** @description IP address of the Event */
      ip?: string;
      /**
       * Format: date-time
       * @description Datestring of the Event time
       */
      created: string;
    };
    GetAutoreplyResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Is the autoreply enabled (true) or not (false) */
      status: boolean;
      /** @description Name that is used for the From: header in autoreply message */
      name: string;
      /** @description Subject line for the autoreply. If empty then uses subject of the original message */
      subject: string;
      /** @description HTML formatted content of the autoreply message */
      html: string;
      /** @description Plaintext formatted content of the autoreply message */
      text: string;
      /**
       * Format: date-time
       * @description Datestring of the start of the autoreply
       */
      start: string;
      /**
       * Format: date-time
       * @description Datestring of the end of the autoreply
       */
      end: string;
    };
    GetDkimKeyResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the DKIM */
      id: string;
      /** @description The domain this DKIM key applies to */
      domain: string;
      /** @description DKIM selector */
      selector: string;
      /** @description Key description */
      description: string;
      /** @description Key fingerprint (SHA1) */
      fingerprint: string;
      /** @description Public key in DNS format (no prefix/suffix, single line) */
      publicKey: string;
      dnsTxt: components["schemas"]["DnsTxt"];
      /**
       * Format: date-time
       * @description Datestring
       */
      created: string;
    };
    GetDkimKeysResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description DKIM listing */
      results: components["schemas"]["GetDkimKeysResult"][];
    };
    GetTLSCertsResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /**
       * @description How many results were found
       * @example 541
       */
      total: number;
      /**
       * @description Current page number. Derived from page query argument
       * @example 1
       */
      page: number;
      /**
       * @description Either a cursor string or false if there are not any previous results
       * @example false
       */
      previousCursor: string;
      /**
       * @description Either a cursor string or false if there are not any next results
       * @example eyIkb2lkIjoiNWRmMWZkMmQ3NzkyNTExOGI2MDdjNjg0In0
       */
      nextCursor: string;
      /** @description Certificate listing */
      results: components["schemas"]["GetTLSCertResult"][];
    };
    UpdateDkimKeyResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the DKIM */
      id: string;
      /** @description The domain this DKIM key applies to */
      domain: string;
      /** @description DKIM selector */
      selector: string;
      /** @description Key description */
      description: string;
      /** @description Key fingerprint (SHA1) */
      fingerprint: string;
      /** @description Public key in DNS format (no prefix/suffix, single line) */
      publicKey: string;
      dnsTxt: components["schemas"]["DnsTxt"];
    };
    UpdateTLSCertResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /**
       * @description ID of the certificate
       * @example 609d201236d1d936948f23b1
       */
      id: string;
      /**
       * @description The server name this certificate applies to
       * @example imap.example.com
       */
      servername: string;
      /**
       * @description Key description
       * @example Some notes about this certificate
       */
      description?: string;
      /**
       * @description Key fingerprint (SHA1)
       * @example 59:8b:ed:11:5b:4f:ce:b4:e5:1a:2f:35:b1:6f:7d:93:40:c8:2f:9c:38:3b:cd:f4:04:92:a1:0e:17:2c:3f:f3
       */
      fingerprint: string;
      /**
       * Format: date-time
       * @description Certificate expiration time
       * @example 2021-06-26T21:55:55.000Z
       */
      expires?: string;
      /**
       * @description SAN servernames listed in the certificate
       * @example [
       *   "example.com",
       *   "www.example.com"
       * ]
       */
      altNames?: string[];
    };
    ResolveIdResponse: {
      /**
       * @description Indicates successful response
       * @example true
       */
      success: boolean;
      /**
       * @description Unique ID (24 byte hex)
       * @example 609d201236d1d936948f23b1
       */
      id: string;
    };
    RecoverInfoResponse: {
      /**
       * @description Indicates successful response
       * @example true
       */
      success: boolean;
      /**
       * @description ID of the deleted User
       * @example 609d201236d1d936948f23b1
       */
      user: string;
      /**
       * @description Username of the User
       * @example andris
       */
      username: string;
      /**
       * @description Calculated quota usage for the user
       * @example 2423070
       */
      storageUsed: number;
      /**
       * @description List of tags associated with the User
       * @example [
       *   "domain:andrisreinman.com"
       * ]
       */
      tags: string[];
      /**
       * Format: date-time
       * @description Datestring of the time the user was deleted
       */
      deleted: string;
      /**
       * @description List of email addresses that can be restored
       * @example [
       *   "andris@andrisreinman.com"
       * ]
       */
      recoverableAddresses: string[];
    };
    GetAllowedDomainResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Domain list */
      results: components["schemas"]["GetAllowedDomainResult"][];
    };
    CreateAllowedDomainResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID for the created record */
      id: string;
    };
    GetBlockedDomainResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Domain list */
      results: components["schemas"]["GetBlockedDomainResult"][];
    };
    CreateBlockedDomainResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID for the created record */
      id: string;
    };
    GetDomainAliasResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Alias */
      id: string;
      /** @description Alias domain */
      alias: string;
      /** @description Alias target */
      domain: string;
      /**
       * Format: date-time
       * @description Datestring of the time the alias was created
       */
      created: string;
    };
    GetDomainAliasesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Aliases listing */
      results: components["schemas"]["GetDomainAliasesResult"][];
    };
    CreateDomainAliasResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Domain Alias */
      id: string;
    };
    GetFilterResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID for the Filter */
      id: string;
      /** @description Name of the Filter */
      name: string;
      query: components["schemas"]["Query"];
      action: components["schemas"]["Action"];
      /** @description If true, then this filter is ignored */
      disabled: boolean;
    };
    UpdateFilterResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID for the created Filter */
      id: string;
    };
    GetAllFiltersResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Address listing */
      results: components["schemas"]["GetAllFiltersResult"][];
    };
    GetFiltersResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Filter usage limits for the user account */
      limits: {
        /** @description How many filters are allowed */
        allowed?: number;
        /** @description How many filters have been created */
        used?: number;
      };
      /** @description Filter description */
      results: components["schemas"]["GetFiltersResult"][];
    };
    GetMailboxResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Mailbox ID */
      id: string;
      /** @description Name for the mailbox (unicode string) */
      name: string;
      /** @description Full path of the mailbox, folders are separated by slashes, ends with the mailbox name (unicode string) */
      path: string;
      specialUse: components["schemas"]["SpecialUse"];
      /** @description Modification sequence number. Incremented on every change in the mailbox. */
      modifyIndex: number;
      /** @description Mailbox subscription status. IMAP clients may unsubscribe from a folder. */
      subscribed: boolean;
      /** @description Is the folder hidden or not */
      hidden: boolean;
      /** @description How many messages are stored in this mailbox */
      total: number;
      /** @description How many unseen messages are stored in this mailbox */
      unseen: number;
    };
    GetMailboxesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description List of user mailboxes */
      results: components["schemas"]["GetMailboxesResult"][];
    };
    CreateMailboxResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Mailbox ID */
      id: string;
    };
    GetMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Message */
      id: number;
      /** @description ID of the Mailbox */
      mailbox: string;
      /** @description ID of the User */
      user: string;
      envelope: components["schemas"]["Envelope"];
      /** @description ID of the Thread */
      thread: string;
      from: components["schemas"]["Address"];
      to?: components["schemas"]["Address"];
      cc?: components["schemas"]["Address"];
      bcc?: components["schemas"]["Address"];
      /** @description Message subject */
      subject: string;
      /** @description Message-ID header */
      messageId: string;
      /**
       * Format: date-time
       * @description Date string from header
       */
      date: string;
      /**
       * Format: date-time
       * @description Date string of receive time
       */
      idate?: string;
      list?: components["schemas"]["List"];
      /** @description Datestring, if set then indicates the time after this message is automatically deleted */
      expires?: string;
      /** @description Does this message have a \Seen flag */
      seen: boolean;
      /** @description Does this message have a \Deleted flag */
      deleted: boolean;
      /** @description Does this message have a \Flagged flag */
      flagged: boolean;
      /** @description Does this message have a \Draft flag */
      draft: boolean;
      /** @description An array of HTML string. Every array element is from a separate mime node, usually you would just join these to a single string */
      html?: string[];
      /** @description Plaintext content of the message */
      text?: string;
      /** @description Attachments for the message */
      attachments?: components["schemas"]["Attachments"][];
      verificationResults?: components["schemas"]["VerificationResults"];
      /** @description BIMI logo info. If logo validation failed in any way, then this property is not set */
      bimi?: {
        /** @description If true, then this logo is from a VMC file */
        certified?: boolean;
        /** @description URL of the resource the logo was retrieved from */
        url?: string;
        /** @description Data URL for the SVG image */
        image?: string;
      };
      contentType: components["schemas"]["ContentType"];
      /** @description Custom metadata object set for this message */
      metaData: { [key: string]: unknown };
      /** @description Referenced message info */
      reference?: { [key: string]: unknown };
      files?: components["schemas"]["Files"];
      /** @description Outbound queue entries */
      outbound?: components["schemas"]["Outbound"][];
    };
    DeleteMessagesInMailboxResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Indicates count of deleted messages */
      deleted: number;
    };
    GetMessagesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Message listing */
      results: components["schemas"]["GetMessagesResult"][];
    };
    UpdateMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description If messages were moved then lists new ID values. Array entry is an array with first element pointing to old ID and second to new ID */
      id: { [key: string]: unknown }[];
      /** @description If messages were not moved, then indicates the number of updated messages */
      updated: number;
    };
    SearchMessagesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Message listing */
      results: components["schemas"]["GetMessagesResult"][];
    };
    SubmitStoredMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Message ID in outbound queue */
      queueId: string;
      message?: components["schemas"]["Message"];
    };
    GetFilesResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description File listing */
      results: components["schemas"]["GetFilesResult"][];
    };
    SubmitMessageResponse: {
      /** @description Indicates successful response */
      success: boolean;
      message: components["schemas"]["MessageWithQueueId"];
    };
    SetupTotp2FAResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Generated TOTP seed value */
      seed: string;
      /** @description Base64 encoded QR code */
      qrcode: string;
    };
    GetUserResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Users unique ID (24 byte hex) */
      id: string;
      /** @description Username of the User */
      username: string;
      /** @description Name of the User */
      name: string;
      /** @description Main email address of the User */
      address: string;
      /** @description Default retention time (in ms). false if not enabled */
      retention: number;
      /** @description List of enabled 2FA methods */
      enabled2fa: string[];
      /** @description Is autoreply enabled or not (start time may still be in the future or end time in the past) */
      autoreply: boolean;
      /** @description If true then received messages are encrypted */
      encryptMessages: boolean;
      /** @description If true then forwarded messages are encrypted */
      encryptForwarded: boolean;
      /** @description Public PGP key for the User that is used for encryption */
      pubKey: string;
      keyInfo: components["schemas"]["KeyInfo"];
      /** @description Custom metadata object set for this user */
      metaData: { [key: string]: unknown };
      /** @description Custom interna metadata object set for this user. Not available for user-role tokens */
      internalData: { [key: string]: unknown };
      /** @description List of forwarding targets */
      targets: string[];
      /** @description Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam */
      spamLevel: number;
      limits: components["schemas"]["UserLimits"];
      /** @description List of tags associated with the User */
      tags: string[];
      /** @description A list of additional email addresses this user can send mail from. Wildcard is allowed. */
      fromWhitelist?: string[];
      /** @description Disabled scopes for this user */
      disabledScopes: components["schemas"]["DisabledScopes"][];
      /** @description If true then the User has a password set and can authenticate */
      hasPasswordSet: boolean;
      /** @description Is the account activated */
      activated: boolean;
      /** @description If true then the user can not authenticate or receive any new mail */
      disabled: boolean;
      /** @description If true then the user can not authenticate */
      suspended: boolean;
    };
    GetUsersResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description User listing */
      results: components["schemas"]["GetUsersResult"][];
    };
    CreateUserResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID for the created User */
      id: string;
    };
    RecalculateQuotaResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Calculated quota usage for the user */
      storageUsed: number;
    };
    ResetUserPasswordResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Temporary password */
      password: string;
    };
    GetWebhooksResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description How many results were found */
      total: number;
      /** @description Current page number. Derived from page query argument */
      page: number;
      /** @description Either a cursor string or false if there are not any previous results */
      previousCursor: string;
      /** @description Either a cursor string or false if there are not any next results */
      nextCursor: string;
      /** @description Webhook listing */
      results: components["schemas"]["GetWebhooksResult"][];
    };
    CreateWebhookResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description ID of the Webhook */
      id: string;
    };
    GetSettingResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Key of the Setting */
      key?: string;
      /** @description Setting value */
      value?: string | number;
    } & {
      id: unknown;
    };
    GetSettingsResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Partial match if requested */
      filter?: string;
      /** @description Setting listing */
      settings: components["schemas"]["GetSettingsResult"][];
    };
    CreateSettingResponse: {
      /** @description Indicates successful response */
      success: boolean;
      /** @description Key of the Setting */
      key?: string;
    } & {
      id: unknown;
    };
    UpdateForwardedAddressRequest: {
      /** @description New address. Only affects normal addresses, special addresses that include * can not be changed */
      address?: string;
      /** @description Identity name */
      name?: string;
      /** @description An array of forwarding targets. The value could either be an email address or a relay url to next MX server ("smtp://mx2.zone.eu:25") or an URL where mail contents are POSTed to. If set then overwrites previous targets array */
      targets?: string[];
      /** @description Daily allowed forwarding count for this address */
      forwards?: number;
      /** @description A list of tags associated with this address */
      tags?: string[];
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      /** @description Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens */
      internalData?: { [key: string]: unknown } | string;
      /** @description If true then disables forwarded address (stops forwarding messages) */
      forwardedDisabled?: boolean;
      autoreply?: components["schemas"]["Autoreply"];
    };
    UpdateUserAddressRequest: {
      /** @description Identity name */
      name?: string;
      /** @description New address if you want to rename existing address. Only affects normal addresses, special addresses that include * can not be changed */
      address?: string;
      /** @description Indicates if this is the default address for the User */
      main: boolean;
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      /** @description Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens */
      internalData?: { [key: string]: unknown } | string;
      /** @description A list of tags associated with this address */
      tags?: string[];
    };
    CreateUserAddressRequest: {
      /** @description E-mail Address */
      address: string;
      /** @description Identity name */
      name?: string;
      /** @description A list of tags associated with this address */
      tags?: string[];
      /** @description Indicates if this is the default address for the User */
      main?: boolean;
      /** @description If true then address value can be in the form of `*@example.com`, `*suffix@example.com` and `username@*`, otherwise using * is not allowed. Static suffix can be up to 32 characters long. */
      allowWildcard?: boolean;
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      /** @description Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens */
      internalData?: { [key: string]: unknown } | string;
    };
    CreateForwardedAddressRequest: {
      /** @description E-mail Address */
      address: string;
      /** @description Identity name */
      name?: string;
      /** @description An array of forwarding targets. The value could either be an email address or a relay url to next MX server ("smtp://mx2.zone.eu:25") or an URL where mail contents are POSTed to */
      targets?: string[];
      /** @description Daily allowed forwarding count for this address */
      forwards?: number;
      /** @description If true then address value can be in the form of `*@example.com`, otherwise using * is not allowed */
      allowWildcard?: boolean;
      /** @description A list of tags associated with this address */
      tags?: string[];
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      /** @description Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens */
      internalData?: { [key: string]: unknown } | string;
      autoreply?: components["schemas"]["Autoreply"];
    };
    RenameDomainRequest: {
      /** @description Old Domain Name */
      oldDomain: string;
      /** @description New Domain Name */
      newDomain: string;
    };
    CreateASPRequest: {
      /** @description Description */
      description: string;
      /**
       * @description List of scopes this Password applies to. Special scope "*" indicates that this password can be used for any scope except "master"
       * @example [
       *   "imap",
       *   "smtp"
       * ]
       */
      scopes: components["schemas"]["AspScopes"][];
      /**
       * @description If true then result contains a mobileconfig formatted file with account config
       * @example true
       */
      generateMobileconfig?: boolean;
      /**
       * @description E-mail address to be used as the account address in mobileconfig file. Must be one of the listed identity addresses of the user. Defaults to the main address of the user
       * @example user@example.com
       */
      address?: string;
      /**
       * @description Optional pregenerated password. Must be 16 characters, latin letters only.
       * @example aaaaaaaaaaaaaaaa
       */
      password?: string;
      /**
       * @description TTL in seconds for this password. Every time password is used, TTL is reset to this value
       * @example 3600000
       */
      ttl?: number;
      /** @description Session identifier for the logs */
      sess?: string;
      /**
       * @description IP address for the logs
       * @example 127.0.0.1
       */
      ip?: string;
    };
    RestoreMessageRequest: {
      /** @description ID of the target Mailbox. If not set then original mailbox is used. */
      mailbox?: string;
    };
    RestoreMessagesRequest: {
      /**
       * Format: date-time
       * @description Datestring
       */
      start: string;
      /**
       * Format: date-time
       * @description Datestring
       */
      end: string;
    };
    CreateAuditRequest: {
      /** @description Users unique ID. */
      user: string;
      /**
       * Format: date-time
       * @description Start time as ISO date
       */
      start?: string;
      /**
       * Format: date-time
       * @description End time as ISO date
       */
      end?: string;
      /**
       * Format: date-time
       * @description Expiration date. Audit data is deleted after this date
       */
      expires: string;
    };
    AuthenticateRequest: {
      /** @description Username or E-mail address */
      username: string;
      /** @description Password */
      password: string;
      /** @description Application identifier for security logs */
      protocol?: string;
      /** @description Required scope. One of master, imap, smtp, pop3 */
      scope?: string;
      /** @description If true then generates a temporary access token that is valid for this user. Only available if scope is "master". When using user tokens then you can replace user ID in URLs with "me". */
      token?: boolean;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    UpdateAutoreplyRequest: {
      /** @description Is the autoreply enabled (true) or not (false) */
      status?: boolean;
      /** @description Name that is used for the From: header in autoreply message */
      name?: string;
      /** @description Subject line for the autoreply. If empty then uses subject of the original message */
      subject?: string;
      /** @description HTML formatted content of the autoreply message */
      html?: string;
      /** @description Plaintext formatted content of the autoreply message */
      text?: string;
      /**
       * Format: date-time
       * @description Datestring of the start of the autoreply or boolean false to disable start checks
       */
      start?: string;
      /**
       * Format: date-time
       * @description Datestring of the end of the autoreply or boolean false to disable end checks
       */
      end?: string;
    };
    UpdateDkimKeyRequest: {
      /** @description Domain name this DKIM key applies to. Use "*" as a special value that will be used for domains that do not have their own DKIM key set */
      domain: string;
      /** @description Selector for the key */
      selector: string;
      /** @description Key description */
      description?: string;
      /** @description Pem formatted DKIM private key. If not set then a new 2048 bit RSA key is generated, beware though that it can take several seconds to complete. */
      privateKey?: string;
    };
    UpdateTLSCertRequest: {
      /**
       * @description Server name this TLS certificate applies to
       * @example imap.example.com
       */
      servername: string;
      /**
       * @description If true then private key and certificate are managed automatically by ACME
       * @example false
       */
      acme?: boolean;
      /**
       * @description PEM formatted TLS private key. Optional if certificate is managed by ACME
       * @example -----BEGIN PRIVATE KEY-----
       * MIIEvQIBADA...
       */
      privateKey?: string;
      /**
       * @description PEM formatted TLS certificate or a certificate bundle with concatenated certificate and CA chain. Optional if certificate is managed by ACME
       * @example -----BEGIN CERTIFICATE-----
       * MIIDEDCCAfg...
       */
      cert?: string;
      /** @description CA chain certificates. Not needed if `cert` value is a bundle */
      ca?: string[];
      /**
       * @description Certificate description
       * @example Some notes about this certificate
       */
      description?: string;
    };
    CreateAllowedDomainRequest: {
      /** @description Domain name to allowlist for users/addresses that include this tag */
      domain: string;
    };
    CreateBlockedDomainRequest: {
      /** @description Domain name to blocklist for users/addresses that include this tag */
      domain: string;
    };
    CreateDomainAliasRequest: {
      /** @description Domain Alias */
      alias: string;
      /** @description Domain name this Alias applies to */
      domain: string;
    };
    UpdateFilterRequest: {
      /** @description Name of the Filter */
      name?: string;
      query?: components["schemas"]["Query"];
      action?: components["schemas"]["Action"];
      /** @description If true then this filter is ignored */
      disabled?: boolean;
    };
    CreateFilterRequest: {
      /** @description Name of the Filter */
      name?: string;
      query: components["schemas"]["Query"];
      action: components["schemas"]["Action"];
      /** @description If true then this filter is ignored */
      disabled?: boolean;
    };
    UpdateMailboxRequest: {
      /** @description Full path of the mailbox, use this to rename an existing Mailbox */
      path?: string;
      /** @description Is the folder hidden or not. Hidden folders can not be opened in IMAP. */
      hidden?: boolean;
      /** @description Retention policy for the Mailbox (in ms). Changing retention value only affects messages added to this folder after the change */
      retention?: number;
      /** @description Change Mailbox subscription state */
      subscribed?: boolean;
    };
    CreateMailboxRequest: {
      /** @description Full path of the mailbox, folders are separated by slashes, ends with the mailbox name (unicode string) */
      path: string;
      /** @description Is the folder hidden or not. Hidden folders can not be opened in IMAP. */
      hidden?: boolean;
      /** @description Retention policy for the created Mailbox. Milliseconds after a message added to mailbox expires. Set to 0 to disable. */
      retention?: number;
    };
    UpdateMessageRequest: {
      /** @description Message ID values. Either comma separated numbers (1,2,3) or colon separated range (3:15), or a range from UID to end (3:*) */
      message?: string;
      /** @description ID of the target Mailbox if you want to move messages */
      moveTo?: string;
      /** @description State of the \Seen flag */
      seen?: boolean;
      /** @description State of the \Flagged flag */
      flagged?: boolean;
      /** @description State of the \Draft flag */
      draft?: boolean;
      /** @description Either expiration date or false to turn of autoexpiration */
      expires?: string;
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
    };
    SubmitStoredMessageRequest: {
      /** @description If true then deletes attachment files listed in metaData.files array */
      deleteFiles?: boolean;
      /**
       * Format: date-time
       * @description Datestring for delivery if message should be sent some later time
       */
      sendTime?: string;
    };
    SubmitMessageRequest: {
      reference?: components["schemas"]["Reference"];
      /** @description Mailbox ID where to upload the message. If not set then message is uploaded to Sent Mail folder. */
      mailbox?: string;
      /** @description If true then generated message is not added to the sending queue */
      uploadOnly?: boolean;
      /** @description If true then treats this message as draft (should be used with uploadOnly=true) */
      isDraft?: boolean;
      /**
       * Format: date-time
       * @description Datestring for delivery if message should be sent some later time
       */
      sendTime?: string;
      envelope?: components["schemas"]["EnvelopeUpload"];
      from?: components["schemas"]["Address"];
      /** @description Addresses for the To: header */
      to?: components["schemas"]["AddressOptionalName"][];
      /** @description Addresses for the Cc: header */
      cc?: components["schemas"]["AddressOptionalName"][];
      /** @description Addresses for the Bcc: header */
      bcc?: components["schemas"]["AddressOptionalName"][];
      /** @description Message subject. If not then resolved from Reference message */
      subject: string;
      /** @description Plaintext message */
      text: string;
      /** @description HTML formatted message */
      html: string;
      /** @description Custom headers for the message. If reference message is set then In-Reply-To and References headers are set automatically */
      headers?: components["schemas"]["Header"][];
      /** @description Attachments for the message */
      attachments?: components["schemas"]["AttachmentsUpload"][];
      /** @description Custom metainfo for the message */
      meta?: { [key: string]: unknown };
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    CheckTotp2FARequest: {
      /** @description 6-digit number */
      token: string;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    EnableCustom2FARequest: {
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    EnableTotp2FARequest: {
      /** @description 6-digit number that matches seed value from 2fa/totp/setup */
      token: string;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    SetupTotp2FARequest: {
      /** @description Label text for QR code (defaults to username) */
      label?: string;
      /** @description Description text for QR code (defaults to "WildDuck") */
      issuer?: string;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    UpdateUserRequest: {
      /** @description Name of the User */
      name?: string;
      /** @description If provided then validates against account password before applying any changes */
      existingPassword?: string;
      /** @description New password for the account. Set to boolean false to disable password usage for the master scope, Application Specific Passwords would still be allowed */
      password?: string;
      /** @description If true then password is already hashed, so store as is. Supported hashes: pbkdf2, bcrypt ($2a, $2y, $2b), md5 ($1), sha512 ($6), sha256 ($5), argon2 ($argon2d, $argon2i, $argon2id). Stored hashes are rehashed to pbkdf2 on first successful password check. */
      hashedPassword?: boolean;
      /** @description If false then validates provided passwords against Have I Been Pwned API. Experimental, so validation is disabled by default but will be enabled automatically in some future version of WildDuck. */
      allowUnsafe?: boolean;
      /** @description A list of tags associated with this user */
      tags?: string[];
      /** @description Default retention time (in ms). Set to 0 to disable */
      retention?: number;
      /** @description If true then all messages sent through MSA are also uploaded to the Sent Mail folder. Might cause duplicates with some email clients, so disabled by default. */
      uploadSentMessages?: boolean;
      /** @description If true then received messages are encrypted */
      encryptMessages?: boolean;
      /** @description If true then forwarded messages are encrypted */
      encryptForwarded?: boolean;
      /** @description Public PGP key for the User that is used for encryption. Use empty string to remove the key */
      pubKey?: string;
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      /** @description Optional internal metadata, must be an object or JSON formatted string of an object. Not available for user-role tokens */
      internalData?: { [key: string]: unknown };
      /** @description Language code for the User */
      language?: string;
      /** @description An array of forwarding targets. The value could either be an email address or a relay url to next MX server ("smtp://mx2.zone.eu:25") or an URL where mail contents are POSTed to */
      targets?: string[];
      /** @description Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam */
      spamLevel?: number;
      /** @description Allowed quota of the user in bytes */
      quota?: number;
      /** @description How many messages per 24 hour can be sent */
      recipients?: number;
      /** @description How many messages per 24 hour can be forwarded */
      forwards?: number;
      /** @description How many filters are allowed for this account */
      filters?: number;
      /** @description How many bytes can be uploaded via IMAP during 24 hour */
      imapMaxUpload?: number;
      /** @description How many bytes can be downloaded via IMAP during 24 hour */
      imapMaxDownload?: number;
      /** @description How many bytes can be downloaded via POP3 during 24 hour */
      pop3MaxDownload?: number;
      /** @description How many latest messages to list in POP3 session */
      pop3MaxMessages?: number;
      /** @description How many parallel IMAP connections are alowed */
      imapMaxConnections?: number;
      /** @description How many messages can be received from MX during 60 seconds */
      receivedMax?: number;
      /** @description If true, then disables 2FA for this user */
      disable2fa?: boolean;
      /** @description List of scopes that are disabled for this user ("imap", "pop3", "smtp") */
      disabledScopes?: components["schemas"]["DisabledScopes"][];
      /** @description If true then disables user account (can not login, can not receive messages) */
      disabled?: boolean;
      /** @description A list of additional email addresses this user can send mail from. Wildcard is allowed. */
      fromWhitelist?: string[];
      /** @description If true then disables authentication */
      suspended?: boolean;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    CreateUserRequest: {
      /** @description Username of the User. Dots are allowed but informational only ("user.name" is the same as "username"). */
      username: string;
      /** @description Name of the User */
      name?: string;
      /** @description Password for the account. Set to boolean false to disable password usage for the master scope, Application Specific Passwords would still be allowed */
      password: string;
      /** @description If true then password is already hashed, so store as is. Supported hashes: pbkdf2, bcrypt ($2a, $2y, $2b), md5 ($1), sha512 ($6), sha256 ($5), argon2 ($argon2d, $argon2i, $argon2id). Stored hashes are rehashed to pbkdf2 on first successful password check. */
      hashedPassword?: boolean;
      /** @description If false then validates provided passwords against Have I Been Pwned API. Experimental, so validation is disabled by default but will be enabled automatically in some future version of WildDuck. */
      allowUnsafe?: boolean;
      /** @description Default email address for the User (autogenerated if not set) */
      address?: string;
      /** @description If true then do not autogenerate missing email address for the User. Only needed if you want to create a user account that does not have any email address associated */
      emptyAddress?: boolean;
      /** @description If true then requires the user to change password, useful if password for the account was autogenerated */
      requirePasswordChange?: boolean;
      /** @description A list of tags associated with this user */
      tags?: string[];
      /** @description If true then autogenerated address gets the same tags as the user */
      addTagsToAddress?: boolean;
      /** @description Default retention time (in ms). Set to 0 to disable */
      retention?: number;
      /** @description If true then all messages sent through MSA are also uploaded to the Sent Mail folder. Might cause duplicates with some email clients, so disabled by default. */
      uploadSentMessages?: boolean;
      /** @description If true then received messages are encrypted */
      encryptMessages?: boolean;
      /** @description If true then forwarded messages are encrypted */
      encryptForwarded?: boolean;
      /** @description Public PGP key for the User that is used for encryption. Use empty string to remove the key */
      pubKey?: string;
      /** @description Optional metadata, must be an object or JSON formatted string */
      metaData?: { [key: string]: unknown } | string;
      /** @description Optional metadata for internal use, must be an object or JSON formatted string of an object. Not available for user-role tokens */
      internalData?: { [key: string]: unknown } | string;
      /** @description Language code for the User */
      language?: string;
      /** @description An array of forwarding targets. The value could either be an email address or a relay url to next MX server ("smtp://mx2.zone.eu:25") or an URL where mail contents are POSTed to */
      targets?: string[];
      /** @description Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam */
      spamLevel?: number;
      /** @description Allowed quota of the user in bytes */
      quota?: number;
      /** @description How many messages per 24 hour can be sent */
      recipients?: number;
      /** @description How many messages per 24 hour can be forwarded */
      forwards?: number;
      /** @description How many filters are allowed for this account */
      filters?: number;
      /** @description How many bytes can be uploaded via IMAP during 24 hour */
      imapMaxUpload?: number;
      /** @description How many bytes can be downloaded via IMAP during 24 hour */
      imapMaxDownload?: number;
      /** @description How many bytes can be downloaded via POP3 during 24 hour */
      pop3MaxDownload?: number;
      /** @description How many latest messages to list in POP3 session */
      pop3MaxMessages?: number;
      /** @description How many parallel IMAP connections are alowed */
      imapMaxConnections?: number;
      /** @description How many messages can be received from MX during 60 seconds */
      receivedMax?: number;
      mailboxes?: components["schemas"]["Mailboxes"];
      /** @description List of scopes that are disabled for this user ("imap", "pop3", "smtp") */
      disabledScopes?: components["schemas"]["DisabledScopes"][];
      /** @description A list of additional email addresses this user can send mail from. Wildcard is allowed. */
      fromWhitelist?: string[];
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    LogoutUserRequest: {
      /** @description Message to be shown to connected IMAP client */
      reason?: string;
    };
    UserRestoreRequest: {
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    ResetUserPasswordRequest: {
      /**
       * Format: date-time
       * @description Allow using the generated password not earlier than provided time
       */
      validAfter?: string;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    CreateWebhookRequest: {
      /** @description An array of event types to match. For prefix match use ".*" at the end (eg. "user.*") or "*" for all types */
      type: string[];
      /** @description User ID to match (only makes sense for user specific resources) */
      user?: string;
      /** @description URL to POST data to */
      url: string;
    };
    CreateSettingRequest: {
      /** @description Setting value */
      value: string | number;
      /** @description Session identifier for the logs */
      sess?: string;
      /** @description IP address for the logs */
      ip?: string;
    };
    GetAddressesResult: {
      /** @description ID of the Address */
      id: string;
      /** @description Identity name */
      name: string;
      /** @description E-mail address string */
      address: string;
      /** @description User ID this address belongs to if this is a User address */
      user: string;
      /** @description If true then it is a forwarded address */
      forwarded: boolean;
      /** @description If true then the forwarded address is disabled */
      forwardedDisabled: boolean;
      /** @description List of forwarding targets */
      target?: string[];
    };
    GetUserAddressesResult: {
      /** @description ID of the Address */
      id: string;
      /** @description Identity name */
      name: string;
      /** @description E-mail address string */
      address: string;
      /** @description Indicates if this is the default address for the User */
      main: boolean;
      /**
       * Format: date-time
       * @description Datestring of the time the address was created
       */
      created: string;
      /** @description List of tags associated with the Address */
      tags: string[];
      /** @description Metadata object (if available) */
      metaData?: { [key: string]: unknown };
      /** @description Internal metadata object (if available), not included for user-role requests */
      internalData?: { [key: string]: unknown };
    };
    GetUserAddressesregisterResult: {
      /**
       * @description ID of the Address
       * @example 507f1f77bcf86cd799439011
       */
      id: string;
      /**
       * @description Name from address header
       * @example John Doe
       */
      name?: string;
      /**
       * @description E-mail address string
       * @example john@example.com
       */
      address: string;
    };
    GetASPsResult: {
      /** @description ID of the Application Password */
      id: string;
      /** @description Description */
      description: string;
      /** @description Allowed scopes for the Application Password */
      scopes: components["schemas"]["AspScopes"][];
      lastUse: components["schemas"]["LastUse"];
      /**
       * Format: date-time
       * @description Datestring
       */
      created: string;
    };
    GetArchivedMessagesResult: {
      /** @description ID of the Message (24 byte hex) */
      id: string;
      /** @description ID of the Mailbox */
      mailbox: string;
      /** @description ID of the Thread */
      thread: string;
      from: components["schemas"]["Address"];
      /** @description Recipients in To: field */
      to: components["schemas"]["Address"][];
      /** @description Recipients in Cc: field */
      cc: components["schemas"]["Address"][];
      /** @description Recipients in Bcc: field. Usually only available for drafts */
      bcc: components["schemas"]["Address"][];
      /** @description Message subject */
      subject: string;
      /**
       * Format: date-time
       * @description Date string from header
       */
      date: string;
      /**
       * Format: date-time
       * @description Date string of receive time
       */
      idate?: string;
      /** @description First 128 bytes of the message */
      intro: string;
      /** @description Does the message have attachments */
      attachments: boolean;
      /** @description Is this message alread seen or not */
      seen: boolean;
      /** @description Does this message have a \Deleted flag (should not have as messages are automatically deleted once this flag is set) */
      deleted: boolean;
      /** @description Does this message have a \Flagged flag */
      flagged: boolean;
      contentType: components["schemas"]["ContentType"];
    };
    GetAuthlogResult: {
      /** @description ID of the Event */
      id: string;
      /** @description Action identifier */
      action: string;
      /** @description Did the action succeed */
      result: string;
      /** @description Session identifier */
      sess?: string;
      /** @description IP address of the Event */
      ip?: string;
      /**
       * Format: date-time
       * @description Datestring of the Event time
       */
      created: string;
    };
    GetDkimKeysResult: {
      /** @description ID of the DKIM */
      id: string;
      /** @description The domain this DKIM key applies to */
      domain: string;
      /** @description DKIM selector */
      selector: string;
      /** @description Key description */
      description: string;
      /** @description Key fingerprint (SHA1) */
      fingerprint: string;
      /**
       * Format: date-time
       * @description Datestring
       */
      created: string;
    };
    GetTLSCertResult: {
      /**
       * @description ID of the certificate
       * @example 609d201236d1d936948f23b1
       */
      id: string;
      /**
       * @description The server name this certificate applies to
       * @example imap.example.com
       */
      servername: string;
      /**
       * @description If true then private key and certificate are managed automatically by ACME
       * @example false
       */
      acme?: boolean;
      /**
       * @description Key description
       * @example Some notes about this certificate
       */
      description: string;
      /**
       * @description Key fingerprint (SHA1)
       * @example 59:8b:ed:11:5b:4f:ce:b4:e5:1a:2f:35:b1:6f:7d:93:40:c8:2f:9c:38:3b:cd:f4:04:92:a1:0e:17:2c:3f:f3
       */
      fingerprint: string;
      /**
       * Format: date-time
       * @description Datestring
       * @example 2021-05-13T20:06:46.179Z
       */
      created: string;
      /**
       * Format: date-time
       * @description Certificate expiration time
       * @example 2021-06-26T21:55:55.000Z
       */
      expires?: string;
      /**
       * @description SAN servernames listed in the certificate
       * @example [
       *   "example.com",
       *   "www.example.com"
       * ]
       */
      altNames?: string[];
    };
    GetAllowedDomainResult: {
      /** @description Entry ID */
      id: string;
      /** @description allowlisted domain name */
      domain: string;
    };
    GetBlockedDomainResult: {
      /** @description Entry ID */
      id: string;
      /** @description blocklisted domain name */
      domain: string;
    };
    GetDomainAliasesResult: {
      /** @description ID of the Domain Alias */
      id: string;
      /** @description Domain Alias */
      alias: string;
      /** @description The domain this alias applies to */
      domain: string;
    };
    GetAllFiltersResult: {
      /** @description Filter ID */
      id: string;
      /** @description User ID */
      user: string;
      /** @description Name for the filter */
      name: string;
      /**
       * Format: date-time
       * @description Datestring of the time the filter was created
       */
      created: string;
      query: string[][];
      action: string[][];
      /** @description If true, then this filter is ignored */
      disabled: boolean;
      /** @description List of forwarding targets */
      targets?: string[];
    };
    GetFiltersResult: {
      /** @description Filter ID */
      id: string;
      /** @description Name for the filter */
      name: string;
      /**
       * Format: date-time
       * @description Datestring of the time the filter was created
       */
      created: string;
      query: string[][];
      action: string[][];
      /** @description If true, then this filter is ignored */
      disabled: boolean;
    };
    GetMailboxesResult: {
      /** @description Mailbox ID */
      id: string;
      /** @description Name for the mailbox (unicode string) */
      name: string;
      /** @description Full path of the mailbox, folders are separated by slashes, ends with the mailbox name (unicode string) */
      path: string;
      /** @description Either special use identifier or null. One of \Drafts, \Junk, \Sent or \Trash */
      specialUse: string;
      /** @description Modification sequence number. Incremented on every change in the mailbox. */
      modifyIndex: number;
      /** @description Mailbox subscription status. IMAP clients may unsubscribe from a folder. */
      subscribed: boolean;
      /** @description Default retention policy for this mailbox (in ms). If set then messages added to this maibox will be automatically deleted after retention time. */
      retention?: number;
      /** @description Is the folder hidden or not */
      hidden: boolean;
      /** @description How many messages are stored in this mailbox */
      total: number;
      /** @description How many unseen messages are stored in this mailbox */
      unseen: number;
    };
    GetMessagesResult: {
      /** @description ID of the Message */
      id: number;
      /** @description ID of the Mailbox */
      mailbox: string;
      /** @description ID of the Thread */
      thread: string;
      /** @description Amount of messages in the Thread. Included if threadCounters query argument was true */
      threadMessageCount?: number;
      from: components["schemas"]["Address"];
      /** @description Recipients in To: field */
      to: components["schemas"]["Address"][];
      /** @description Recipients in Cc: field */
      cc: components["schemas"]["Address"][];
      /** @description Recipients in Bcc: field. Usually only available for drafts */
      bcc: components["schemas"]["Address"][];
      /** @description Message subject */
      subject: string;
      /**
       * Format: date-time
       * @description Date string from header
       */
      date: string;
      /**
       * Format: date-time
       * @description Date string of receive time
       */
      idate?: string;
      /** @description Message size in bytes */
      size: number;
      /** @description First 128 bytes of the message */
      intro: string;
      /** @description Does the message have attachments */
      attachments: boolean;
      /** @description Is this message alread seen or not */
      seen: boolean;
      /** @description Does this message have a \Deleted flag (should not have as messages are automatically deleted once this flag is set) */
      deleted: boolean;
      /** @description Does this message have a \Flagged flag */
      flagged: boolean;
      /** @description Does this message have a \Answered flag */
      answered: boolean;
      /** @description Does this message have a $Forwarded flag */
      forwarded: boolean;
      contentType: components["schemas"]["ContentType"];
      /** @description Custom metadata value. Included if metaData query argument was true */
      metaData?: { [key: string]: unknown };
    };
    GetFilesResult: {
      /** @description ID of the File */
      id: string;
      /** @description Filename */
      filename: string;
      /** @description Content-Type of the file */
      contentType: string;
      /** @description File size */
      size: number;
    };
    GetUsersResult: {
      /** @description Users unique ID (24 byte hex) */
      id: string;
      /** @description Username of the User */
      username: string;
      /** @description Name of the User */
      name: string;
      /** @description Main email address of the User */
      address: string;
      /** @description List of tags associated with the User' */
      tags: string[];
      /** @description List of forwarding targets */
      targets: string[];
      /** @description List of enabled 2FA methods */
      enabled2fa: string[];
      /** @description Is autoreply enabled or not (start time may still be in the future or end time in the past) */
      autoreply: boolean;
      /** @description If true then received messages are encrypted */
      encryptMessages: boolean;
      /** @description If true then forwarded messages are encrypted */
      encryptForwarded: boolean;
      quota: components["schemas"]["Quota"];
      /** @description Custom metadata value. Included if metaData query argument was true */
      metaData?: { [key: string]: unknown };
      /** @description Custom metadata value for internal use. Included if internalData query argument was true and request was not made using user-role token */
      internalData?: { [key: string]: unknown };
      /** @description If true then the User has a password set and can authenticate */
      hasPasswordSet: boolean;
      /** @description Is the account activated */
      activated: boolean;
      /** @description If true then the user can not authenticate or receive any new mail */
      disabled: boolean;
      /** @description If true then the user can not authenticate */
      suspended: boolean;
    };
    GetWebhooksResult: {
      /** @description Webhooks unique ID (24 byte hex) */
      id: string;
      /** @description An array of event types this webhook matches */
      type: string[];
      /** @description User ID or null */
      user: string;
      /** @description Webhook URL */
      url: string;
    };
    /** @enum {string} */
    AspScopes: "imap" | "pop3" | "smtp" | "*";
    /** @enum {string} */
    DisabledScopes: "imap" | "pop3" | "smtp";
    /** @enum {string} */
    Order: "asc" | "desc";
    GetSettingsResult: {
      /** @description Setting key */
      key: string;
      /** @description Setting value */
      value?: string | number;
      /** @description Setting name */
      name?: string;
      /** @description Setting description */
      description?: string;
      /** @description Default value for this key */
      default?: string | number;
      /** @description Value subtype */
      type?: string;
      /** @description If true then the value is set */
      custom?: boolean;
    };
  };
}

interface operations {
  getForwardedAddress: {
    parameters: {
      path: {
        /** ID of the Address */
        address: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetForwardedAddressResponse"];
        };
      };
    };
  };
  updateForwardedAddress: {
    parameters: {
      path: {
        /** ID of the Address */
        address: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateForwardedAddressRequest"];
      };
    };
  };
  deleteForwardedAddress: {
    parameters: {
      path: {
        /** ID of the Address */
        address: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getUserAddress: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Address */
        address: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserAddressResponse"];
        };
      };
    };
  };
  updateUserAddress: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Address */
        address: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserAddressRequest"];
      };
    };
  };
  deleteUserAddress: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Address */
        address: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  resolveAddress: {
    parameters: {
      path: {
        /** ID of the Address or e-mail address string */
        address: string;
      };
      query: {
        /** If true then resolves also wildcard addresses */
        allowWildcard?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResolveAddressResponse"];
        };
      };
    };
  };
  getAddresses: {
    parameters: {
      query: {
        /** Partial match of an address */
        query?: string;
        /** Partial match of a forward email address or URL */
        forward?: string;
        /** Comma separated list of tags. The Address must have at least one to be set */
        tags?: string;
        /** Comma separated list of tags. The Address must have all listed tags to be set */
        requiredTags?: string;
        /** If true, then includes metaData in the response */
        metaData?: boolean;
        /** If true, then includes internalData in the response. Not shown for user-role tokens. */
        internalData?: boolean;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAddressesResponse"];
        };
      };
    };
  };
  getUserAddresses: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** If true, then includes metaData in the response */
        metaData?: boolean;
        /** If true, then includes internalData in the response. Not shown for user-role tokens. */
        internalData?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserAddressesResponse"];
        };
      };
    };
  };
  /** Add a new email address for a User. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both "firstlast@example.com" and "first.last@example.com" Special addresses `*@example.com`, `*suffix@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument) */
  createUserAddress: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateUserAddressResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserAddressRequest"];
      };
    };
  };
  /** Lists addresses from email headers. Includes addresses both from sent and received messages. Sorted by last usage. */
  getUserAddressregister: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** Prefix of an address or a name */
        query: string;
        /** How many records to return */
        limit?: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserAddressesregisterResponse"];
        };
      };
    };
  };
  /** Add a new forwarded email address. Addresses can contain unicode characters. Dots in usernames are normalized so no need to create both "firstlast@example.com" and "first.last@example.com" Special addresses `*@example.com` and `username@*` catches all emails to these domains or users without a registered destination (requires allowWildcard argument) */
  createForwardedAddress: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateForwardedAddressResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateForwardedAddressRequest"];
      };
    };
  };
  /** Renames domain names for addresses, DKIM keys and Domain Aliases */
  renameDomain: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RenameDomainRequest"];
      };
    };
  };
  getASP: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Application Password */
        asp: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetASPResponse"];
        };
      };
    };
  };
  deleteASP: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Application Password */
        asp: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getASPs: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** If not true then skips entries with a TTL set */
        showAll?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetASPsResponse"];
        };
      };
    };
  };
  createASP: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateASPResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateASPRequest"];
      };
    };
  };
  /** Archive contains all recently deleted messages besides Drafts etc. */
  getArchivedMessages: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Ordering of the records by insert date */
        order?: components["schemas"]["Order"];
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetArchivedMessagesResponse"];
        };
      };
    };
  };
  /** Restores a single archived message by moving it back to the mailbox it was deleted from or to provided target mailbox. If target mailbox does not exist, then the message is moved to INBOX. */
  restoreMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** Message ID */
        message: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["RestoreMessageResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RestoreMessageRequest"];
      };
    };
  };
  /** Initiates a restore task to move archived messages of a date range back to the mailboxes the messages were deleted from. If target mailbox does not exist, then the messages are moved to INBOX. */
  restoreMessages: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RestoreMessagesRequest"];
      };
    };
  };
  /** This method returns information about stored audit */
  getAudit: {
    parameters: {
      path: {
        /** ID of the Audit */
        audit: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAuditResponse"];
        };
      };
    };
  };
  /** This method returns a mailbox file that contains all audited emails */
  getAuditEmails: {
    parameters: {
      path: {
        /** ID of the Audit */
        audit: string;
      };
    };
    responses: {
      /** Success */
      200: unknown;
    };
  };
  /** Initiates a message audit */
  createAudit: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAuditResponse"];
        };
      };
    };
    /** Initiates a message audit */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAuditRequest"];
      };
    };
  };
  authenticate: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["AuthenticateResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AuthenticateRequest"];
      };
    };
  };
  /** This method invalidates currently used authentication token. If token is not provided then nothing happens */
  invalidateAccessToken: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** Check if an username exists and can be used for authentication */
  preauth: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates successful response */
            success: boolean;
            /** @description ID of authenticated User */
            id: string;
            /** @description Username of authenticated User */
            username: string;
            /** @description The scope this authentication is valid for */
            scope: string;
            /** @description List of enabled 2FA mechanisms */
            require2fa: string[];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Username or E-mail address */
          username: string;
          /** @description Required scope. One of master, imap, smtp, pop3 */
          scope?: string;
          /** @description Session identifier for the logs */
          sess?: string;
          /** @description IP address for the logs */
          ip?: string;
        };
      };
    };
  };
  getAuthlog: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** Limit listing only to values with specific action value */
        action?: string;
        /** Limit listing only to values with specific IP address */
        filterIp?: string;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAuthlogResponse"];
        };
      };
    };
  };
  getAuthlogEvent: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Event */
        event: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAuthlogEventResponse"];
        };
      };
    };
  };
  getAutoreply: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutoreplyResponse"];
        };
      };
    };
  };
  updateAutoreply: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAutoreplyRequest"];
      };
    };
  };
  deleteAutoreply: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getDkimKey: {
    parameters: {
      path: {
        /** ID of the DKIM */
        dkim: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetDkimKeyResponse"];
        };
      };
    };
  };
  deleteDkimKey: {
    parameters: {
      path: {
        /** ID of the DKIM */
        dkim: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getDkimKeys: {
    parameters: {
      query: {
        /** Partial match of a Domain name */
        query?: string;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetDkimKeysResponse"];
        };
      };
    };
  };
  /** Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name. */
  updateDkimKey: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateDkimKeyResponse"];
        };
      };
    };
    /** Add a new DKIM key for a Domain or update existing one. There can be single DKIM key registered for each domain name. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDkimKeyRequest"];
      };
    };
  };
  resolveDkim: {
    parameters: {
      path: {
        /** DKIM domain */
        domain: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResolveIdResponse"];
        };
      };
    };
  };
  getTLSCerticate: {
    parameters: {
      path: {
        /** ID of the TLS certificate */
        cert: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetTLSCertResult"];
        };
      };
    };
  };
  deleteTlsCert: {
    parameters: {
      path: {
        /** ID of the TLS certificate */
        cert: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getTLSCerticates: {
    parameters: {
      query: {
        /** Partial match of a server name */
        query?: string;
        /** Match `query` value against SAN as well (including wildcard names) */
        altNames?: boolean;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetTLSCertsResponse"];
        };
      };
    };
  };
  /**
   * Add a new TLS certificate for a server name or update existing one. You can add a single certificate for each server name but SAN names are supported as well. For example you can add a sertificate for "mydomain.com" that includes "\*.mydomain.com" in SAN and the same certificate would be used for requests that do not have it's own server name registered but match the SAN value.
   * > NB! you must ensure yourself that the `servername` value is actually listed in certificate's common name or SAN as WildDuck is going to use this certificate regardless.
   */
  updateTLSCertificate: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateTLSCertResponse"];
        };
      };
    };
    /** Add a new TLS certificate for a server name or update existing one */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTLSCertRequest"];
      };
    };
  };
  resolveTLSCertificate: {
    parameters: {
      path: {
        /** Server name */
        servername: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResolveIdResponse"];
        };
      };
    };
  };
  deleteDomainListing: {
    parameters: {
      path: {
        /** Listed domains unique ID */
        domain: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getAllowedDomain: {
    parameters: {
      path: {
        /** Tag to look for */
        tag: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAllowedDomainResponse"];
        };
      };
    };
  };
  /** If an email is sent from a domain that is listed in the allowlist then it is never marked as spam. Lists apply for tagged users. */
  createAllowedDomain: {
    parameters: {
      path: {
        /** Tag to look for */
        tag: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAllowedDomainResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAllowedDomainRequest"];
      };
    };
  };
  getBlockedDomain: {
    parameters: {
      path: {
        /** Tag to look for */
        tag: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetBlockedDomainResponse"];
        };
      };
    };
  };
  /** If an email is sent from a domain that is listed in the blocklist then it is always marked as spam. Lists apply for tagged users. */
  createBlockedDomain: {
    parameters: {
      path: {
        /** Tag to look for */
        tag: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateBlockedDomainResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateBlockedDomainRequest"];
      };
    };
  };
  getDomainAlias: {
    parameters: {
      path: {
        /** ID of the Alias */
        alias: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetDomainAliasResponse"];
        };
      };
    };
  };
  deleteDomainAlias: {
    parameters: {
      path: {
        /** ID of the Alias */
        alias: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getDomainAliases: {
    parameters: {
      query: {
        /** Partial match of a Domain Alias or Domain name */
        query?: string;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetDomainAliasesResponse"];
        };
      };
    };
  };
  /** Add a new Alias for a Domain. This allows to accept mail on username@domain and username@alias */
  createDomainAlias: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateDomainAliasResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDomainAliasRequest"];
      };
    };
  };
  resolveDomainAlias: {
    parameters: {
      path: {
        /** Alias domain */
        alias: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResolveIdResponse"];
        };
      };
    };
  };
  /** Export data for matching users. Export dump does not include emails, only account structure (user data, password hashes, mailboxes, filters, etc.). A special "export"-role access token is required for exporting and importing. */
  createExport: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
    };
    /** Export data for matching users */
    requestBody: {
      content: {
        "application/json": {
          /** @description An array of User ID values to export */
          users?: string[];
          /** @description An array of user tags to export. If set then at least one tag must exist on an user. */
          tags?: string[];
        };
      };
    };
  };
  /** Import data from an export dump. If a database entry already exists, it is not modified. A special "export"-role access token is required for exporting and importing. */
  createImport: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description How many database entries were found from the export file */
            entries?: number;
            /** @description How many database entries were imported from the export file */
            imported?: number;
            /** @description How many database entries were not imported due to some error */
            failed?: number;
            /** @description How many database existing entries were not imported */
            existing?: number;
          };
        };
      };
    };
    /** Import user data */
    requestBody: {
      content: {
        "application/octet-stream": string;
      };
    };
  };
  getFilter: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Filters unique ID */
        filter: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetFilterResponse"];
        };
      };
    };
  };
  /** This method updates Filter data. To unset a value, use empty strings */
  updateFilter: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Filters unique ID */
        filter: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateFilterResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFilterRequest"];
      };
    };
  };
  deleteFilter: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Filters unique ID */
        filter: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getAllFilters: {
    parameters: {
      query: {
        /** Partial match of a forward email address or URL */
        forward?: string;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: number;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAllFiltersResponse"];
        };
      };
    };
  };
  getFilters: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetFiltersResponse"];
        };
      };
    };
  };
  createFilter: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateFilterResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFilterRequest"];
      };
    };
  };
  getMailbox: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Mailbox unique ID. Special use folders and INBOX can not be deleted */
        mailbox: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetMailboxResponse"];
        };
      };
    };
  };
  updateMailbox: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Mailbox unique ID. Special use folders and INBOX can not be deleted */
        mailbox: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateMailboxRequest"];
      };
    };
  };
  deleteMailbox: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
        /** Mailbox unique ID. Special use folders and INBOX can not be deleted */
        mailbox: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getMailboxes: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
      query: {
        /** Should the response include only folders with specialUse flag set. */
        specialUse?: boolean;
        /** Hidden folders are not included in the listing by default. */
        showHidden?: boolean;
        /** Should the response include counters (total + unseen). Counters come with some overhead. */
        counters?: boolean;
        /** Should the response include mailbox size in bytes. Size numbers come with a lot of overhead as an aggregated query is ran. */
        sizes?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetMailboxesResponse"];
        };
      };
    };
  };
  createMailbox: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateMailboxResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateMailboxRequest"];
      };
    };
  };
  getMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
      query: {
        /** If true then marks message as seen */
        markAsSeen?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetMessageResponse"];
        };
      };
    };
  };
  deleteMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getMessages: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
      };
      query: {
        /** If true, then returns only unseen messages */
        unseen?: boolean;
        /** If true, then includes metaData in the response */
        metaData?: boolean;
        /** If true, then includes threadMessageCount in the response. Counters come with some overhead */
        threadCounters?: boolean;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Ordering of the records by insert date */
        order?: components["schemas"]["Order"];
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetMessagesResponse"];
        };
      };
    };
  };
  /** This method updates message flags and also allows to move messages to a different mailbox */
  updateMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateMessageResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateMessageRequest"];
      };
    };
  };
  /** This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from structured data fields, then do not use the raw property. */
  uploadMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UploadMessageResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UploadMessageRequest"];
      };
    };
  };
  deleteMessagesInMailbox: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
      };
      query: {
        /** Schedule deletion task */
        async?: boolean;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["DeleteMessagesInMailboxResponse"];
        };
      };
    };
  };
  /** This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message. */
  forwardStoredMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ForwardStoredMessageResponse"];
        };
      };
    };
    /** This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForwardStoredMessageRequest"];
      };
    };
  };
  /** This method returns attachment file contents in binary form */
  getMessageAttachment: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** ID of the Message */
        message: number;
        /** ID of the Attachment */
        attachment: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
    };
  };
  /** This method returns the full RFC822 formatted source of the stored message */
  getMessageSource: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** ID of the Message */
        message: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "text/plain": { [key: string]: unknown };
        };
      };
    };
  };
  /** You can delete outbound emails that are still in queue. Queue ID can be found from the `outbound` property of a stored email. */
  deleteOutboundMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** Outbound queue ID of the message */
        queueId: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** This method allows searching for matching messages. */
  searchMessages: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** ID of the Mailbox */
        mailbox?: string;
        /** Thread ID */
        thread?: string;
        /** Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc. */
        query?: string;
        /** Datestring for the earliest message storing time */
        datestart?: string;
        /** Datestring for the latest message storing time */
        dateend?: string;
        /** Partial match for the From: header line */
        from?: string;
        /** Partial match for the To: and Cc: header lines */
        to?: string;
        /** Partial match for the Subject: header line */
        subject?: string;
        /** If true, then matches only messages with attachments */
        attachments?: boolean;
        /** If true, then matches only messages with \Flagged flags */
        flagged?: boolean;
        /** If true, then matches only messages without \Seen flags */
        unseen?: boolean;
        /** If true, then matches messages not in Junk or Trash */
        searchable?: boolean;
        /** Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc. */
        "or.query"?: string;
        /** Partial match for the From: header line */
        "or.from"?: string;
        /** Partial match for the To: and Cc: header lines */
        "or.to"?: string;
        /** Partial match for the Subject: header line */
        "or.subject"?: string;
        /** Minimal message size in bytes */
        minSize?: number;
        /** Maximal message size in bytes */
        maxSize?: number;
        /** If true, then includes threadMessageCount in the response. Counters come with some overhead */
        threadCounters?: boolean;
        /** How many records to return */
        limit?: number;
        /** Ordering of the records by insert date. If no order is supplied, results are sorted by heir mongoDB ObjectId. */
        order?: components["schemas"]["Order"];
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SearchMessagesResponse"];
        };
      };
    };
  };
  /** This method allows applying an action to all matching messages. This is an async method so that it will return immediately. Actual modifications are run in the background. */
  searchApplyMessages: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates if the action succeeded or not */
            success?: boolean;
            /** @description ID of the scheduled operation */
            scheduled?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description ID of the Mailbox */
          mailbox?: string;
          /** @description Thread ID */
          thread?: string;
          /** @description Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc. */
          query?: string;
          /**
           * Format: date-time
           * @description Datestring for the earliest message storing time
           */
          datestart?: string;
          /**
           * Format: date-time
           * @description Datestring for the latest message storing time
           */
          dateend?: string;
          /** @description Partial match for the From: header line */
          from?: string;
          /** @description Partial match for the To: and Cc: header lines */
          to?: string;
          /** @description Partial match for the Subject: header line */
          subject?: string;
          /** @description If true, then matches only messages with attachments */
          attachments?: boolean;
          /** @description If true, then matches only messages with \Flagged flags */
          flagged?: boolean;
          /** @description If true, then matches only messages without \Seen flags */
          unseen?: boolean;
          /** @description If true, then matches messages not in Junk or Trash */
          searchable?: boolean;
          /** @description At least onOne of the included terms must match */
          or?: {
            /** @description Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc. */
            query?: string;
            /** @description Partial match for the From: header line */
            from?: string;
            /** @description Partial match for the To: and Cc: header lines */
            to?: string;
            /** @description Partial match for the Subject: header line */
            subject?: string;
          };
          /** @description Minimal message size in bytes */
          minSize?: number;
          /** @description Maximal message size in bytes */
          maxSize?: number;
          /** @description Define actions to take with matching messages */
          action?: {
            /** @description ID of the target Mailbox if you want to move messages */
            moveTo?: string;
            /** @description State of the \Seen flag */
            seen?: boolean;
            /** @description State of the \Flagged flag */
            flagged?: boolean;
          };
        };
      };
    };
  };
  /** This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder. */
  submitStoredMessage: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the Mailbox */
        mailbox: string;
        /** Message ID */
        message: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SubmitStoredMessageResponse"];
        };
      };
    };
    /** This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubmitStoredMessageRequest"];
      };
    };
  };
  /** This method returns stored file contents in binary form */
  getFile: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the File */
        file: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
    };
  };
  deleteFile: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
        /** ID of the File */
        file: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getFiles: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** Partial match of a filename */
        query?: string;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetFilesResponse"];
        };
      };
    };
  };
  /** This method allows to upload an attachment to be linked from a draft */
  uploadFile: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** @description Name of the file */
          filename?: string;
          /** @description MIME type of the file. Is detected from the file name by default */
          contentType?: string;
          /** @description Encoding of the file content. Useful if you want to upload the file in base64 encoded format. Valid options "base64", "hex", "utf8" */
          encoding?: string;
          /** Format: binary */
          content: string;
        };
      };
    };
  };
  /** Use this method to send emails from a user account */
  submitMessage: {
    parameters: {
      path: {
        /** Users unique ID */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SubmitMessageResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubmitMessageRequest"];
      };
    };
  };
  /** This method checks if a TOTP token provided by a User is valid for authentication */
  checkTotp2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CheckTotp2FARequest"];
      };
    };
  };
  /** This method disables all 2FA mechanisms a user might have set up */
  disable2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** This method disables account password for IMAP/POP3/SMTP */
  enableCustom2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EnableCustom2FARequest"];
      };
    };
  };
  /** This method disables custom 2FA. If it was the only 2FA set up, then account password for IMAP/POP3/SMTP gets enabled again */
  disableCustom2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** This method disables TOTP for a user. Does not affect other 2FA mechanisms a user might have set up */
  disableTotp2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
      query: {
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** This method enables TOTP for a user by verifying the seed value generated from 2fa/totp/setup */
  enableTotp2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EnableTotp2FARequest"];
      };
    };
  };
  /** This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint */
  setupTotp2FA: {
    parameters: {
      path: {
        /** ID of the User */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SetupTotp2FAResponse"];
        };
      };
    };
    /** This method generates TOTP seed and QR code for 2FA. User needs to verify the seed value using 2fa/totp/enable endpoint */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetupTotp2FARequest"];
      };
    };
  };
  getUser: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponse"];
        };
      };
    };
  };
  updateUser: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequest"];
      };
    };
  };
  /** This method deletes user and address entries from DB and schedules a background task to delete messages. You can call this method several times even if the user has already been deleted, in case there are still some pending messages. */
  deleteUser: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
      query: {
        /** Delete user entry from registry but keep all user data until provided date. User account is fully recoverable up to that date. */
        deleteAfter?: string;
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** This api call returns an EventSource response. Listen on this stream to get notifications about changes in messages and mailboxes. Returned events are JSON encoded strings */
  getUpdates: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "text/event-stream": string;
        };
      };
    };
  };
  resolveUser: {
    parameters: {
      path: {
        /** Username of the User. Alphanumeric value. Must start with a letter, dots are allowed but informational only ("user.name" is the same as "username") */
        username: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResolveIdResponse"];
        };
      };
    };
  };
  restoreUserInfo: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
      query: {
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["RecoverInfoResponse"];
        };
      };
    };
  };
  /** Use this endpoint to cancel a timed deletion task scheduled by `DELETE /user/{id}`. If user data is not yet deleted then the account is fully recovered, except any email addresses that might have been already recycled */
  restoreUser: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserRestoreRequest"];
      };
    };
  };
  getUsers: {
    parameters: {
      query: {
        /** Partial match of username or default email address */
        query?: string;
        /** Partial match of a forward email address or URL */
        forward?: string;
        /** Comma separated list of tags. The User must have at least one to be set */
        tags?: string;
        /** Comma separated list of tags. The User must have all listed tags to be set */
        requiredTags?: string;
        /** If true, then includes metaData in the response */
        metaData?: boolean;
        /** If true, then includes internalData in the response. Not shown for user-role tokens. */
        internalData?: boolean;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetUsersResponse"];
        };
      };
    };
  };
  createUser: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateUserResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserRequest"];
      };
    };
  };
  /** This method recalculates quota usage for a User. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact. */
  recalculateQuota: {
    parameters: {
      path: {
        /** Users unique ID. */
        user: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["RecalculateQuotaResponse"];
        };
      };
    };
  };
  /** This method recalculates quota usage for all Users. Normally not needed, only use it if quota numbers are way off. This method is not transactional, so if the user is currently receiving new messages then the resulting value is not exact. */
  recalculateQuotaAllUsers: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  /** This method logs out all user sessions in IMAP */
  logoutUser: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LogoutUserRequest"];
      };
    };
  };
  /** This method generates a new temporary password for a User. Additionally it removes all two-factor authentication settings */
  resetUserPassword: {
    parameters: {
      path: {
        /** Users unique ID. */
        id: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResetUserPasswordResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResetUserPasswordRequest"];
      };
    };
  };
  deleteWebhook: {
    parameters: {
      path: {
        /** ID of the Webhook */
        webhook: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getWebhooks: {
    parameters: {
      query: {
        /** Prefix or exact match. Prefix match must end with ".*", eg "channel.*". Use "*" for all types */
        type: string;
        /** User ID */
        user?: string;
        /** How many records to return */
        limit?: number;
        /** Current page number. Informational only, page numbers start from 1 */
        page?: number;
        /** Cursor value for next page, retrieved from nextCursor response value */
        next?: string;
        /** Cursor value for previous page, retrieved from previousCursor response value */
        previous?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetWebhooksResponse"];
        };
      };
    };
  };
  /** Create new webhook */
  createWebhook: {
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateWebhookResponse"];
        };
      };
    };
    /** Create new webhook */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWebhookRequest"];
      };
    };
  };
  getSetting: {
    parameters: {
      path: {
        /** Key of the Setting */
        setting: string;
      };
      query: {
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetSettingResponse"];
        };
      };
    };
  };
  /** Create a new or update an existing setting */
  createSetting: {
    parameters: {
      path: {
        /** Key of the Setting */
        setting: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSettingResponse"];
        };
      };
    };
    /** Create or Update Setting */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSettingRequest"];
      };
    };
  };
  deleteSetting: {
    parameters: {
      path: {
        /** Key of the Setting */
        setting: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
    };
  };
  getSettings: {
    parameters: {
      query: {
        /** Optional partial match of the Setting key */
        filter?: string;
        /** Session identifier for the logs */
        sess?: string;
        /** IP address for the logs */
        ip?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetSettingsResponse"];
        };
      };
    };
  };
}

interface external {}
